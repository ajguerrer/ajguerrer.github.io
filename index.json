[
{
	"uri": "https://ajguerrer.github.io/unit-testing/bigger_picture/",
	"title": "The Bigger Picture",
	"tags": [],
	"description": "",
	"content": "What Makes a Good or Bad Test?  Unit testing enables sustainable growth in software projects by acting as a form of insurance against regressions. A good test has a lower maintenance cost than the cost of fixing the bugs it prevents. Code is a liability, not an asset, and tests are code too. Tests that don\u0026rsquo;t verify business value, raise false alarms, run slow, and are difficult to maintain, do more harm than good.  Code Coverage Metrics Coverage metrics are a good negative indicator for test quality, but a bad positive one.\nCurly Braces Curly braces count.\nbool IsStringLong(const std::string\u0026amp; input) { if (input.length() \u0026gt; 5) { return true; } return false; } TEST(IsStringLong, ShortString) { bool result = IsStringLong(\u0026#34;abc\u0026#34;); EXPECT_EQ(result, false); } 75% of 4 lines covered.\nRefactoring Refactoring can be used to \u0026ldquo;game\u0026rdquo; coverage by condensing the code.\nbool IsStringLong(const std::string\u0026amp; input) { return input.length() \u0026gt; 5; } 100% of 1 line covered.\nTest Quality Coverage metrics say nothing about the quality of the test.\nbool IsStringLong(const std::string\u0026amp; input) { if (input.length() \u0026gt; 5) { return true; } return false; } TEST(IsStringLong, ShortString) { bool result1 = IsStringLong(\u0026#34;abc\u0026#34;); bool result2 = IsStringLong(\u0026#34;abcdef\u0026#34;); } 100% of 4 lines covered.\nExternal Dependencies Coverage metrics do not include coverage of external libraries.\nint Parse(const std::string\u0026amp; input) { return std::atoi(input.c_str()); } TEST(IsStringLong, ShortString) { int result = Parse(\u0026#34;5\u0026#34;); EXPECT_EQ(result, 5); } 100% of 1 line covered.\nHospital Analogy - Temperature is another good negative indicator, but a bad positive indicator. Nurses take temperature measurements to see if a patient\u0026rsquo;s body is unwell. But, regulating the patient\u0026rsquo;s temperature is never the goal. Otherwise, hospitals would tend towards more \u0026ldquo;effective\u0026rdquo; strategies, like dumping patients with fevers into ice baths. Instead, nurses continuously monitor a patients temperature while focusing on the root cause of the illness.\n What Makes a Successful Test Suite A successful test suite has the following properties:\n Integrated into the development cycle. Targets only the most important parts of the code base. Provides maximum value with minimum maintenance costs.  Enforcing test quality is a tough problem; one that requires personal judgement and skill.\nDependency Classification Dependencies may be shared or private; mutable or immutable; internal or external.\n Private - Managed and consumed exclusively by the executable. Shared - Managed and/or consumed by another executable. Immutable - State cannot change in the lifetime of the executable. Mutable - State may change in the lifetime of the executable. Internal - Exists within the executable. External Exists outside the executable.  Executable in this context may refer to a production application or a test executable containing a suite of test(s).\n Test Isolation Varying degrees of isolation can be used when writing tests:\n Heavy Isolation - Replace all mutable dependencies with test doubles. Development tends to start at the top of the object graph and work it\u0026rsquo;s way down. Light Isolation - Replace all mutable, shared dependencies with test doubles. Development tends to start at the bottom of the object graph and work it\u0026rsquo;s way up.  Granularity Heavy isolation helps increase granularity. However, it is easy to fall into the trap of testing implementation details instead of behavior.\nWhen I call my dog, he moves his front left leg, followed by his front right leg, then the back right leg, his head turns, and the tail starts wagging.  What is the purpose of those movements?\nWhen I call my dog, he comes right to me.  A test should tell a story about the problem your code helps to solve, and this story should be cohesive and meaningful to a business expert.\nCoupling Heavy isolation can make it easier to test coupled classes. Substituting a classes dependencies with test doubles can help break up coupling in a large graph of dependencies. However, dependance on test doubles is a good negative indicator of quality code design.\nFeedback Heavy isolation makes it easier to narrow down bugs, while light isolation tends to produce cascades of failing tests. However, this issue can be mitigated by running tests regularly.\nTest Structure  Arrange, Act, then Assert (AAA). Watch out for Act and Assert sections larger than one line, which may indicate the test:  Verifies more than one behavior and needs to be split. Requires verification of more than one outcome, a.k.a invariant violation.   Arrange sections should not be placed inside test fixtures. Doing so:  Introduces coupling between tests. Decreases readability.   Simplify tedious Arrange sections with the factory pattern. Avoid using conditional logic, including loop conditions. Name tests using plain english, describing behavior from the perspective of a business expert. Tests that verify the same behavior with different values may be parameterized, but never at the expense of readability. Consider an assertion library that reads fluently.  "
},
{
	"uri": "https://ajguerrer.github.io/unit-testing/making_tests_work/",
	"title": "Making your Tests Work for You",
	"tags": [],
	"description": "",
	"content": "Four Pillars of a Good Test  Protection against regressions - Ability to indicate the presence of regressions. Resistance to refactoring - Degree to which a test can sustain refactoring without producing a false positive. Fast feedback - Measure of how quickly the test executes. Maintainability - Ability to read and run the test.    Error Types Functionality is Correct Functionality is Broken   Test Passes True negative False negative (indicates poor protection against regressions)   Test Fails False positive (indicates poor resistance to refactoring) True positive   $$Test\\ accuracy = {Signal\\ (True\\ positives) \\over Noise\\ (False\\ positives)}$$\nThe Ideal Test {Protection against regressions, Resistance to refactoring, Fast feedback} - Choose two.\nAlways chose to maximize resistance to refactoring. Then, test size becomes a slider between protection against regressions and fast feedback.\nA diverse ratio of test sizes provides an ideal amount of both protection against regressions and fast feedback. For any non-trivial production system, test counts should form a pyramid where the test count shrinks as test size grows.\nPreventing False Positives When tests fail for the wrong reasons, developers quickly loose trust in their tests. However, without trustworthy tests, refactoring is risky. This trap leads to real bugs slipping through.\nFast positives are formed from coupling between the test and implementation details:\nTEST(Render, IsCorrect) { std::ifstream in(\u0026#34;message_renderer.cc\u0026#34;); std::stringstream sstr; sstr \u0026lt;\u0026lt; in.rdbuf(); EXPECT_EQ(sstr.str(), R\u0026#34;(#include \u0026#34;message_renderer.h\u0026#34; #include \u0026#34;body_renderer.h\u0026#34;#include \u0026#34;title_renderer.h\u0026#34;#include \u0026#34;footer_renderer.h\u0026#34; #include \u0026lt;memory\u0026gt;#include \u0026lt;numeric\u0026gt;#include \u0026lt;string\u0026gt; MessageRenderer::MessageRenderer() : sub_renderers_({std::make_unique\u0026lt;TitleRenderer\u0026gt;(), std::make_unique\u0026lt;BodyRenderer\u0026gt;(), std::make_unique\u0026lt;FooterRenderer\u0026gt;()}) {} std::string MessageRenderer::Render(const Message\u0026amp; message) { return std::accumulate(sub_renderers_.begin(), sub_renderers_.end(), std::string{}, [\u0026amp;](std::string m, std::shared_ptr\u0026lt;Renderer\u0026gt; r) { return std::move(m) + r-\u0026gt;Render(message); }); })\u0026#34;); }  Instead of testing the code, test the behavior.\nTEST(Render, BasicMessage) { MessageRenderer renderer; const Message message{title : \u0026#34;a\u0026#34;, body : \u0026#34;b\u0026#34;, footer : \u0026#34;c\u0026#34;}; std::string html = renderer.Render(message); EXPECT_EQ(html, \u0026#34;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;a\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;b\u0026lt;/body\u0026gt;\u0026lt;footer\u0026gt;c\u0026lt;/footer\u0026gt;\u0026#34;); }  Types of Test Doubles  Mock (mock, spy) - Emulate and verify outgoing interactions from the SUT. Stub (stub, dummy, fake) - Emulate incoming interactions to the SUT.  The term mock can also refer to the mocking framework itself. Mocking frameworks are also generally responsible for creating stubs which can be confusing.\n Mocks can emulate interactions like stubs, but stubs should never assert interactions like mocks. Asserting interactions with stubs is over-specification, a common anti-pattern.\nEncapsulation A well-designed API hides all implementation details behind a private API, leaving only observable behavior in the public API. Implementation details should never leak into the public API.\nInvariant violation API\u0026rsquo;s that require several steps to achieve an individual goal are prone to invariant violation.\nclass User { public: void SetName(const std::string\u0026amp; name) { name_ = name; } std::string NormalizeName(const std::string\u0026amp; name) { return std::string(absl::StripAsciiWhitespace(name)).substr(50); } private: std::string name_; };  Client must remember to NormalizeName before SetName.\nstd::string normalized_name = user.NormalizeName(new_name); user.SetName(normalized_name);  A client should be able to achieve any individual goal atomically.\nclass User { public: void SetName(const std::string\u0026amp; name) { name_ = NormalizeName(name); } private: std::string NormalizeName(const std::string\u0026amp; name) { return std::string(absl::StripAsciiWhitespace(name)).substr(50); } std::string name_; };  Client no longer needs to be concerned about NormalizeName.\nuser.SetName(new_name);  Leaking state Public access to state that isn\u0026rsquo;t directly related to a client\u0026rsquo;s goal is considered leaking state.\nclass MessageRenderer : public Renderer { public: std::vector\u0026lt;std::shared_ptr\u0026lt;Renderer\u0026gt;\u0026gt; GetSubRenderers() { return sub_renderers_; } virtual std::string Render(const Message\u0026amp; message); private: std::vector\u0026lt;std::shared_ptr\u0026lt;Renderer\u0026gt;\u0026gt; sub_renderers_; };  Keep the public API surface as small as possible while still meeting the clients needs.\nclass MessageRenderer : public Renderer { public: virtual std::string Render(const Message\u0026amp; message); private: std::vector\u0026lt;std::unique_ptr\u0026lt;Renderer\u0026gt;\u0026gt; sub_renderers_; };  Styles of Unit Testing  Output-based - Verify output with a given input. Requires pure functions. State-based - Perform operation, then verify state of SUT and collaborators. Communication-based - Perform operation, then verify communication with collaborators.     Style Output-based State-based Communication-based     Resistance to refactoring High Medium Medium   Maintainability High Medium Low    Hexagonal Architecture Hexagonal architecture, proposed by Alistair Cockburn, breaks applications into two layers:\n Domain layer - Logic and models essential to the business domain. Controller layer - All other responsibilities of the application.  Interaction between the Domain layer and the Controller layer follows three guidelines:\n The Domain layer is isolated from the Controller layer. The Domain layer may not depend on the Controller layer, but the Controller layer may depend on the Domain layer. Communication with external applications is handled by the Controller layer, not the Domain layer.  The Domain layer has high cyclomatic complexity and domain significance, while the Controller layer has a large number of collaborators. Code that is both complex and involves many collaborators is overcomplicated and what Hexagonal architecture aims to dissolve.\nCommunication Communication can be classified into two different types:\n Intra-process - Communication within the application; implementation details. Inter-process - Communication with other applications; observable behavior.  Mocks are necessary for emulating external applications and verifying inter-system communication patterns. However, mocks couple tests to implementation details, reducing their resistance to refactoring. For this reason, the use of mocks should be avoided when dealing with intra-system communication. External dependencies only accessible by the application, are implementation details too, and should not be mocked either.\nFunctional Architecture Functional architecture builds off of Hexagonal architecture with an added guideline that business logic is written in a functional paradigm. The architecture generally flows in a three step process:\n The Controller layer gathers and prepare input. The Domain layer makes decisions based on prepared input. The Controller layer converts decisions into side effects.   Object-oriented programming makes code understandable by encapsulating moving parts. Functional programming makes code understandable by minimizing moving parts. \u0026ndash;Michael Feathers\n Functional architecture trades maintainability for performance; pure functions tend to eagerly load data when they could have been lazy.\nController Orchestration Functional architecture assumes a clearcut pipeline of inputs, decisions, and side effects. However, production applications are rarely that simple. Decisions may involve gathering more input followed by making additional decisions. There are three strategies to consider:\n Eagerly gather all the input - Preserve controller simplicity and isolated domain logic, but concede performance. Inject dependencies into the Domain layer - Preserve controller simplicity and performance, but concede isolated domain logic. Allow controller orchestration - Preserve isolated domain logic and performance, but concede controller simplicity.  Isolated domain logic is an attribute that should always be maximized because it has a huge impact on maintainability and resistance to refactoring. Injecting dependencies into the Domain layer is rule out.\nIn cases where performance is not critical, feel free to stick to a Functional architecture and eagerly gather input. Otherwise, allow controllers to orchestrate gathering input to meet the needs of the Domain layer.\nController orchestration will make controllers more complex, but complexity can be mitigated with familiar patterns like switching on a result or listening for Domain layer events.\n "
},
{
	"uri": "https://ajguerrer.github.io/unit-testing/integration_testing/",
	"title": "Integration Testing",
	"tags": [],
	"description": "",
	"content": "Role of Integration Tests Integration tests verify:\n Interactions with external dependencies. Edge cases unsuitable for a unit test.  Each integration test should choose a happy path that exercises as many shared external dependencies as possible while staying within a single use case. If a single integration test doesn\u0026rsquo;t cover all shared external dependencies, write more until all external dependencies are covered.\nTo keep maintenance costs low, check as many edge cases as possible with unit tests before resorting to an integration test.\n Edge cases that immediately stop the current operation without changing state adhere to the Fail Fast principle and don\u0026rsquo;t require an integration test.\n While unit tests are great for testing domain logic, integration tests are great for testing controllers.\nInterfaces Genuine abstractions are discovered, not invented. For an interface to be genuine, it must have at least two implementations. Otherwise, the the added cognitive complexity isn\u0026rsquo;t worth it.\nInterfaces enable mocking. Write an interface to mock shared external dependencies. However, not all external dependencies need an interface. Private external dependencies don\u0026rsquo;t need mocks and therefore don\u0026rsquo;t benefit from an interface, unless there is a need to be to swap them with another implementation in production.\nLayering Adding layers of indirection where they are not appropriate makes code hard to reason with. Aim to have as few layers as possible. Most applications only need three layers: Domain, Controller, and Infrastructure. The Domain and Controller Layers are already familiar. The Infrastructure Layer provides utility libraries such as logging and networking.\nLogging Logging falls under two categories:\n Support logging - messages are intended to be consumed by support staff and system admins; observable behavior. Diagnostic logging - messages are intended to be consumed by developers; implementation detail.  Since Support logging is observable behavior, it is worth the testing effort. Diagnostic logging, however, is an implementation detail and isn\u0026rsquo;t worth testing.\nThe Domain layer should not have dependencies, including loggers. The Controller layer may inject a logger, or the Domain layer may emit a log event.\n Effective logging maximizes the signal to noise ratio. Support logging cannot be controlled because its a business requirement, but Diagnostic logging can. Minimize diagnostic logging in the Domain layer, only adding it for debugging and then subsequently removing it once finished.\nMocking Best Practices  Mocks are for integration tests only - Mentioned in Hexagonal Architecture, only shared external dependencies should be mocked. Unit tests target the Domain layer which shouldn\u0026rsquo;t communicate with external dependencies. Never mock private external dependencies - When a private external dependency is too difficult or prohibitive to setup, don\u0026rsquo;t try to mock it out. If that dependency cannot be tested as-is, it defeats the point of integration testing and should not be tested at all. Mock the furthest edges of the system - Mock the type that directly communicates with a shared dependency, not the wrapper. Verify the message sent to a shared dependency, not a call to a class you wrote. Doing so maximizes resistance against regressions. Use as many mocks as necessary per test - One mock per test is a common misconception. It\u0026rsquo;s irrelevant how many mocks it takes to verify one unit of behavior. The number of mocks depends solely on the number of shared external dependencies participating in the unit of behavior. Verify the absence of unexpected messages too - It is not enough to verify your system is sending the correct messages to shared external dependencies, unexpected messages are a source of bugs too. Mock only the types you own - If your using a third party library to communicate with a shared external dependency, write a adapter for it and mock the adapter instead. Third-party libraries have arcane inner workings, so it\u0026rsquo;s futile to try to emulate their behavior.  Testing the Database Setup Be able to build your database from a series of migration scripts checked into source control. This includes tables, views, indexes, stored procedures, reference data and anything else critical to run the database in production.\nReference data is data that is necessary for the application to run, but isn\u0026rsquo;t actively modified by the application.\n Migration scripts should be used in both testing and production. Once committed to source control, don\u0026rsquo;t modify them. Make a new migration script instead of fixing the old one, unless fixing the old one prevents data loss.\nTransactions Transactions are capable of updating sets of data within the same business operation atomically. When transactions are involved, applications need to make two separate types of decisions:\n Which data gets updated to what? Should a set of updates be kept or rolled back?  These decisions should be separated into two different responsibilities:\n Repositories - Can access and modify database data; lifetime lasts the duration of the query. Transactions - Commits or rolls back a set of updates in full; lifetime lasts the duration of the business operation.  Non-relational databases lack transactions. Instead, updates to the document are atomic. Related data should be placed in the same document so that updates don\u0026rsquo;t span more than one document.\n To replicate the production environment as closely as possible, integration tests should wrap the act section in a separate transaction from the arrange and assert sections.\nCleanup There are many ways to cleanup a database between tests:\n Restore a backup database before each test - Works, but is slow. Cleanup data at the end of the test - Might be skipped when test fails. Wrap each test in a transaction and then don\u0026rsquo;t commit - Makes behavior between production and testing inconsistent. Cleanup data at the beginning of the test - Fast, consistent, and won\u0026rsquo;t get skipped.  Best Practices  Avoid in-memory databases - Behavior between production and testing should be consistent. Reuse code in test sections - Arrange with factory or builder pattern, act with decorator pattern, and assert with handmade mocks (a.k.a. Spys). Skip trivial database read tests - Writes are always important because the alter the state of the database. Reads that important or complex should be tested; disregard the rest. Don\u0026rsquo;t test repositories directly - Repositories are a controller, so they shouldn\u0026rsquo;t be complex. The point of an integration test is to cover shared, external dependencies, not controllers.  "
},
{
	"uri": "https://ajguerrer.github.io/unit-testing/antipatterns/",
	"title": "Unit Testing Anti-Patterns",
	"tags": [],
	"description": "",
	"content": "Don\u0026rsquo;t test private methods directly Only test observable behavior. Coupling a test to implementation details will reduce the tests resistance to refactoring.\nclass Order { public: std::string GenerateDescription(); private: float GetPrice(); Customer customer_; std::vector\u0026lt;Product\u0026gt; products_; }; std::string Order::GenerateDescription() { return absl::StrCat(\u0026#34;Customer name: \u0026#34;, customer_.name, \u0026#34;, total number of products: \u0026#34;, products_.size(), \u0026#34;, total price: \u0026#34;, GetPrice()); } float Order::GetPrice() { float basePrice = std::accumulate(products_.begin(), products_.end(), 0.0, sum_base_prices); float discount = customer_.discount; float taxes = std::accumulate(products_.begin(), products_.end(), 0.0, sum_taxes); return basePrice * discount + taxes; }  If a private method is hard to test indirectly, then it either has dead code or is in need of an abstraction.\nclass Order { public: std::string GenerateDescription(); private: Customer customer_; std::vector\u0026lt;Product\u0026gt; products_; }; class PriceCalculator { public: float Calculate(Customer customer, std::vector\u0026lt;Product\u0026gt; products); }; std::string Order::GenerateDescription() { PriceCalculator calc; return absl::StrCat(\u0026#34;Customer name: \u0026#34;, customer_.name, \u0026#34;, total number of products: \u0026#34;, products_.size(), \u0026#34;, total price: \u0026#34;, calc.Calculate(customer_, products_)); } float PriceCalculator::Calculate(Customer customer, std::vector\u0026lt;Product\u0026gt; products) { float basePrice = std::accumulate(products.begin(), products.end(), 0.0, sum_base_prices); float discount = customer.discount; float taxes = std::accumulate(products.begin(), products.end(), 0.0, sum_taxes); return basePrice * discount + taxes; }  Don\u0026rsquo;t expose private state Its tempting to add a way to access internal state for the sake of testing.\nenum class CustomerStatus { kRegular, kPreferred, }; class Customer { public: void Promote() { status_ = CustomerStatus::kPreferred; } float GetDiscount() { return (status_ == CustomerStatus::kPreferred) ? 0.95 : 1; } private: CustomerStatus status_; };  However exposing state will leak implementation details. Instead, look at how the production code uses the class and test accordingly.\nclass Customer { public: Customer(double starting_) void Promote() { status_ = CustomerStatus::kPreferred; } private: CustomerStatus status_; }; TEST(Customer, PromotedCustomerReceivesDiscount) { Customer customer; customer.Promote(); Product\u0026lt;kFujiApple\u0026gt; apple; customer.Purchase(apple); EXPECT_LT(customer.Balance(), apple.Price()); }  Don\u0026rsquo;t leak domain knowledge to tests Don\u0026rsquo;t base expectations off of implementation details.\nclass Calculator { public: int Add(int a, int b) { return a + b; } }; TEST(Calculator, Add) { Calculator calc; int a = 1; int b = 3; int expected = a + b; int actual = calc.Add(a, b); EXPECT_EQ(actual, expected); }  While it may sound counterintuitive at first, using hardcoded values in your tests is a good thing.\nTEST(Calculator, Add) { Calculator calc; EXPECT_EQ(calc.Add(1, 3), 4); }  Don\u0026rsquo;t add production code for tests only Mixing test code with production code only adds to maintenance costs.\nclass Logger { public: explicit Logger(bool is_test_environment) : is_test_environment_(is_test_environment) {} void Log(std::string text) const { if (is_test_environment_) return; std::cout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } private: bool is_test_environment_; };  Instead, write two distinct implementations that share a common interface.\nclass Logger { public: virtual void Log(std::string text) const = 0; }; class ProductionLogger : public Logger { public: void Log(std::string text) const { std::cout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class FakeLogger : public Logger { public: void Log(std::string text) const {} }; class Controller { public: void SomeMethod(const Logger\u0026amp; logger) { logger.Log(\u0026#34;SomeMethod was called\u0026#34;); } };  Don\u0026rsquo;t mock concrete classes Treat urges to mock a concrete class as a warning flag for violating the Single Responsibility Principle.\nclass StatisticsCalculator { public: virtual std::vector\u0026lt;DeliveryRecord\u0026gt; GetDeliveries(int customer_id); Statistic Calculate(int customer_id); }; class CustomerController { public: CustomerController(const StatisticsCalculator\u0026amp; calculator) : calculator_(calculator) {} std::string GetStatistics(int customer_id); private: StatisticsCalculator calculator_; };  std::vector\u0026lt;DeliveryRecord\u0026gt; StatisticsCalculator::GetDeliveries( int customer_id) { /* Call an external dependency to get the list of deliveries */ return std::vector\u0026lt;DeliveryRecord\u0026gt;{}; } std::string CustomerController::GetStatistics(int customer_id) { Statistic stat = calculator_.Calculate(customer_id); return absl::StrCat(\u0026#34;Total weight delivered: \u0026#34;, stat.totalWeight, \u0026#34;. Total cost: \u0026#34;, stat.totalCost); }  class MockStatisticsCalculator : public StatisticsCalculator { MOCK_METHOD(std::vector\u0026lt;DeliveryRecord\u0026gt;, GetDeliveries, (int customer_id), (override)); }; TEST(CustomerController, CustomerWithNoDeliveries) { MockStatisticsCalculator calc; CustomerController controller(calc); std::string result = controller.GetStatistics(1); EXPECT_EQ(\u0026#34;Total weight delivered: 0. Total cost: 0\u0026#34;, result); }  Separate unrelated responsibilities into two different classes, plus an interface for the shared dependencies.\nclass DeliveryGateway { public: virtual ~DeliveryGateway(){}; virtual std::vector\u0026lt;DeliveryRecord\u0026gt; GetDeliveries(int customer_id) = 0; }; class ConcreteDeliveryGateway : public DeliveryGateway { public: std::vector\u0026lt;DeliveryRecord\u0026gt; GetDeliveries(int customer_id); }; class StatisticsCalculator { public: Statistic Calculate(const std::vector\u0026lt;DeliveryRecord\u0026gt;\u0026amp; records); }; class CustomerController { public: CustomerController(const StatisticsCalculator\u0026amp; calculator, std::unique_ptr\u0026lt;DeliveryGateway\u0026gt; gateway) : calculator_(calculator), gateway_(std::move(gateway)) {} std::string GetStatistics(int customer_id); private: StatisticsCalculator calculator_; std::unique_ptr\u0026lt;DeliveryGateway\u0026gt; gateway_; };  std::string CustomerController::GetStatistics(int customer_id) { const std::vector\u0026lt;DeliveryRecord\u0026gt; records = gateway_-\u0026gt;GetDeliveries(customer_id); const Statistic stat = calculator_.Calculate(records); return absl::StrCat(\u0026#34;Total weight delivered: \u0026#34;, stat.totalWeight, \u0026#34;. Total cost: \u0026#34;, stat.totalCost); }  TEST(CustomerController, CustomerWithNoDeliveries) { StatisticsCalculator calc; CustomerController controller(calc, std::make_unique\u0026lt;MockDeliveryGateway\u0026gt;()); std::string result = controller.GetStatistics(1); EXPECT_EQ(\u0026#34;Total weight delivered: 0. Total cost: 0\u0026#34;, result); }  Don\u0026rsquo;t use time as an ambient context Using time as an ambient context adds unnecessary shared dependencies, making testing difficult.\nusing std::chrono::system_clock; using time_point = std::chrono::time_point\u0026lt;system_clock\u0026gt;;  class DateTimeServer { public: DateTimeServer() : now_func_(\u0026amp;system_clock::now) {} void Init(std::function\u0026lt;time_point()\u0026gt; now_func) { now_func_ = now_func; } time_point Now() { return now_func_(); } private: std::function\u0026lt;time_point()\u0026gt; now_func_; };  DateTimeServer server; std::time_t time = system_clock::to_time_t(server.Now()); std::cout \u0026lt;\u0026lt; std::ctime(\u0026amp;time) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::function\u0026lt;time_point()\u0026gt; now([] { std::tm time{tm_mday : 1, tm_mon : 0, tm_year : 120}; return system_clock::from_time_t(std::mktime(\u0026amp;time)); }); server.Init(now); time = system_clock::to_time_t(server.Now()); std::cout \u0026lt;\u0026lt; std::ctime(\u0026amp;time) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;  Instead, inject the time dependency explicitly either as a value or a service.\nclass DateTimeServer { public: virtual ~DateTimeServer(){}; virtual time_point Now() = 0; }; class ConcreteDateTimeServer : public DateTimeServer { public: time_point Now() { return system_clock::now(); } }; class InquiryController { public: InquiryController(std::unique_ptr\u0026lt;DateTimeServer\u0026gt; server) : date_time_server_(std::move(server)) {} void ApproveInquiry(int id); private: std::unique_ptr\u0026lt;DateTimeServer\u0026gt; date_time_server_; };  void InquiryController::ApproveInquiry(int id) { Inquiry inquiry = GetById(id); inquiry.Approve(date_time_server_-\u0026gt;Now()); SaveInquiry(inquiry); }  Prefer injecting values over injecting services.\nvoid InquiryController::ApproveInquiry(int id, time_point date_time) { Inquiry inquiry = GetById(id); inquiry.Approve(date_time); SaveInquiry(inquiry); }  "
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/",
	"title": "Google Testing Blog",
	"tags": [],
	"description": "",
	"content": "Google Google Testing Blog Notes taken from Google Testing Blog with examples in C++ and the Google Test framework.\n "
},
{
	"uri": "https://ajguerrer.github.io/unit-testing/",
	"title": "Unit Testing Principles, Practices, and Patterns",
	"tags": [],
	"description": "",
	"content": "Vladimir Khorikov Unit Testing Principles, Practices, and Patterns Notes taken from Unit Testing Principles, Practices, and Patterns with examples in C++ and the Google Test framework.\n "
},
{
	"uri": "https://ajguerrer.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/general/",
	"title": "General Notes",
	"tags": [],
	"description": "",
	"content": "Test Reliability  Smaller tests run faster, are less flakey, and isolate failures. As a general rule of thumb, favor a composition of 70% small, 20% medium, and 10% large tests.1 Test binary size and memory usage, including third-party testing tools, have a strong correlation on whether a test is flaky.2 Beware of using UI testing to verify underlying functionality. In these cases, it is cheaper and more reliable to have smaller tests that break closer to the source of the problem.3 4 Hermetic servers add speed and reliability into end-to-end tests. A environment is considered Hermetic if it can run an entire system under test on a single machine with fake network connections and database implementations.5 Filter out flakey tests by rerunning failing tests. If a test fails three times in a row, consider it a real failure.6 Build testability into the product. For example, a real-time system can rely on a fake clock instead of a hardware clock. Processes can spawn other processes attached to a debugger with debugging flags.7  Code Quality  Releasing often gives teams an incentive to automate testing and reduce coupling with the rest of the system.8 When a team provides fakes and writes tests for them, they become clients of their own software. Experiencing the perspective of the client gives the team an incentive to make their API easier to use.8 While writing the header first encourages consideration for the interface, writing tests first encourages consideration for how the interface will be used.9 Good code quality is taught, not enforced. Create a culture that teaches code quality through code review, pair programming, and mentoring.7  Productivity  Automation is costly. Automate only the tests that you find yourself running often to reliably catch regressions on features with business value.3 Speed up the feedback loop between test engineers and development engineers. Share the same space, tools, daily stand-ups, and design discussions.3 Effective automation depends on test design. Good test design is built from a solid foundation of manual tests.10 If a test plan isn\u0026rsquo;t worth bothering to update, it isn\u0026rsquo;t worth creating in the first place. A quick brainstorming session will suffice.11 Use formatting tools, like clang-format, to improve readability.12  Infrastructure  Remove the detective work of tracking down bad changes by investing in a pre-submit system that runs automated tests against the commit before it reaches the depot.13 6 Don\u0026rsquo;t fall behind on updating third party dependencies. Update them quickly by setting up CI system with dependencies pinned at head.14 Avoid making more than one branch by putting risky new changes behind feature flags.12 Constantly look for opportunities to make the build system faster. Reduce the amount of code being compiled, replace tools with faster counterparts, and use distributed build systems.15 Release early and release often. Services and websites can deploy rapidly. A good target for client projects is Chromes six week cycle.15  Metrics \u0026amp; Logging  Pre- vs post-production defect ratio and a breakdown of defects by component or functional area help identify holes in test.16 Premature performance optimization makes bad code. Develop in a clean, maintainable and extensible manner first, and then let benchmarks drive performance optimizations.17 Remove unwanted noise by logging with conditional verbosity. Log all levels to a logging queue. If a transaction completes successfully, discard the unimportant levels.18 Use two sets of logging levels, one for production builds and one for development builds.18 Trace the time spent on every significant processing step. Measuring is the only way to detect performance issues or make claims about performance.18 Write automated performance tests for performance sensitive parts of your product.15    https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-from.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2007/10/automating-tests-vs-test-automation.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2008/06/taming-beast-aka-how-to-test-ajax.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2012/10/hermetic-servers.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/10/hackable-projects-pillar-2-debuggability.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2017/02/discomfort-as-tool-for-change.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2008/09/test-first-is-fun_08.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2008/09/presubmit-and-performance.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/09/10-minute-test-plan.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/08/hackable-projects.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/06/burning-test-questions-at-google.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2015/05/multi-repository-development.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/11/hackable-projects-pillar-3.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2007/10/post-release-closing-loop_02.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2007/10/performance-testing.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2013/06/optimal-logging.html \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/testable_code/",
	"title": "Guide to Writing Testable Code",
	"tags": [],
	"description": "",
	"content": "Miško Hevery  You may find Miško\u0026rsquo;s original guide here.\nDependency Injection A testable class is one that can be constructed in isolation or with test double collaborators. Once constructed, they have all the dependencies they need. This is known as Dependency Injection.\nDependencies do not need to be concrete classes. Abstract classes allow testers to leverage inheritance for creating test double collaborators. This is the primary tool in a testers toolkit and the primary benefit Dependency Injection brings.\nFixing violations Below are some examples of constructor flaws and how they can be fixed with Dependency Injection.\nStatic method calls class AccountView { public: AccountView() { user_ = RPCClient::GetInstance().GetUser(); } private: User user_; } TEST(AccountViewTest, SlowAndFlakyTest) { // Unit test is slow and requires working network connection.  AccountView view; };  class AccountView { public: explicit AccountView(const User\u0026amp; user): user_(user) {} private: User user_; }; TEST(AccountViewTest, FastAndReliableTest) { // User does not need to be retrieved over the network.  MockUser user; AccountView view(user); }  Conditional logic class Car { public: explicit Car(CarType type) { switch (type) { case kCoupe: { engine_ = FastEngine(); tires_ = SmoothTires(); break; } case kTruck: { engine_ = StrongEngine(); tires_ = KnobbyTires(); } default: assert(false); } } private: Engine engine_; Tires tires_; }; TEST(CarTest, HardToTest) { // Want a car with fake engine and tires but can only make real ones.  Car car(kCoupe); }  class Car { public: Car(std::unique_ptr\u0026lt;Engine\u0026gt; engine, std::unique_ptr\u0026lt;Tires\u0026gt; tires) : engine_(std::move(engine)), tires_(std::move(tires)) {} private: std::unique_ptr\u0026lt;Engine\u0026gt; engine_; std::unique_ptr\u0026lt;Tires\u0026gt; tires_; }; TEST(CarTest, EasyToTest) { // Car is fully configurable  Car car(std::make_unique\u0026lt;FakeEngine\u0026gt;(), std::make_unique\u0026lt;FakeTires\u0026gt;()); }  Constructing dependencies  class House { public: House() : kitchen_(), bedroom_() {} // ...  private: Kitchen kitchen_; Bedroom bedroom_; }; TEST(HouseTest, HardToTest) { // house is stuck with Kitchen and Bedroom objects  House house; }  class House { public: House(std::unique_ptr\u0026lt;Kitchen\u0026gt; kitchen, std::unique_ptr\u0026lt;Bedroom\u0026gt; bedroom) : kitchen_(std::move(kitchen)), bedroom_(std::move(bedroom)) {} // ...  private: std::unique_ptr\u0026lt;Kitchen\u0026gt; kitchen_; std::unique_ptr\u0026lt;Bedroom\u0026gt; bedroom_; }; TEST(HouseTest, EasyToTest) { // house uses lightweight test doubles  House house(std::make_unique\u0026lt;MockKitchen\u0026gt;(), std::make_unique\u0026lt;MockBedroom\u0026gt;()); }  Partial construction  class VisualVoicemail { public: // Constructs a partially initialized VisualVoicemail.  // Don\u0026#39;t forget to call Initialize in production, or SetCalls in test!  explicit VisualVoicemail(const User\u0026amp; user) : user_(user) {} void Initialize() { calls_ = Server::GetCallsFor(user_); } private: // Hack to allow test access to private methods.  // Making this function public is not a better idea.  friend class VisualVoicemailTest_BrittleDesign_Test; void SetCalls(std::vector\u0026lt;Call\u0026gt;\u0026amp; calls) { calls_ = calls; } User user_; std::vector\u0026lt;Call\u0026gt; calls_; }; TEST(VisualVoicemailTest, BrittleTest) { DummyUser user; VisualVoicemail voicemail(user); std::vector\u0026lt;Call\u0026gt; calls = BuildListOfTestCalls(); voicemail.SetCalls(calls); }  class VisualVoicemail { public: explicit VisualVoicemail(const std::vector\u0026lt;Call\u0026gt;\u0026amp; calls) : calls_(calls) {} private: std::vector\u0026lt;Call\u0026gt; calls_; }; TEST(VisualVoicemailTest, FlexibleTest) { VisualVoicemail voicemail(BuildListOfTestCalls()); }  Law of Demeter A class becomes difficult to test if it gets its dependencies from anywhere besides it\u0026rsquo;s interface. For example, a class may get a dependency by asking one of it dependencies, breaking the Law of Demeter.\nViolations of the Law of Demeter are a sign of bad Dependency Injection, for passing in the wrong dependency, and bad encapsulation, for exposing secondary dependencies in the first place.\nFixing violations Below are examples of Law of Demeter violations and how they can be fixed with accurate interfaces and encapsulation.\nIndirect dependencies class SalesTaxCalculator { public: SalesTaxCalculator(const TaxTable\u0026amp; taxTable) : taxTable_(taxTable) {} float ComputeSalesTax(const User\u0026amp; user, const Invoice\u0026amp; invoice) { // Get the correct dependencies first.  Address address = user.GetAddress(); float amount = invoice.GetSubTotal(); // Then, do the calculation.  return amount * taxTable_.GetTaxRate(address); } public: TaxTable taxTable_; } TEST(SalesTaxCalculatorTest, ComplexTest) { SalesTaxCalculator calc(TaxTable()); User user(Address(\u0026#34;1600 Amphitheater Parkway...\u0026#34;)); Invoice invoice(1, ProductX(95.00)); // ...  EXPECT_EQ(0.09, calc.ComputeSalesTax(user, invoice)); }  class SalesTaxCalculator { public: SalesTaxCalculator(const TaxTable\u0026amp; taxTable) : taxTable_(taxTable) {} float ComputeSalesTax(const Address\u0026amp; address, const float amount) { // Already have the correct dependencies; do the calculation.  return amount * taxTable_.GetTaxRate(address); } public: TaxTable taxTable_; } TEST(SalesTaxCalculatorTest, StraightforwardTest) { SalesTaxCalculator calc(TaxTable()); Address address(\u0026#34;1600 Amphitheater Parkway...\u0026#34;) // ...  EXPECT_EQ(0.09, calc.ComputeSalesTax(address, 95.00)); }  Overusing member access operator class LoginPage { public: LoginPage(std::shared_ptr\u0026lt;RPCClient\u0026gt; client, const HttpRequest\u0026amp; request) : client_(client), request_(request) {} bool Login() { // Even using member access access operator once is one more time than it  // needs to be.  std::string cookie = request_.GetCookie(\u0026#34;g\u0026#34;); // Using a member access operator twice in one statement is right out!  return client_.GetAuthenticator().Authenticate(); } private: std::shared_ptr\u0026lt;RPCClient\u0026gt; client_; HttpRequest request_; }; TEST(LoginPageTest, ComplexBrittleTest) { MockRPCClient mock_client(make_shared\u0026lt;FakeAuthenticator\u0026gt;()); std::vector\u0026lt;Cookie\u0026gt; cookies = {Cookie(\u0026#34;g\u0026#34;, \u0026#34;xyz123\u0026#34;)}; MockHttpRequest mock_request(cookies); LoginPage page(client, request); EXPECT_CALL(mock_client, GetAuthenticator()); EXPECT_CALL(mock_request, GetCookie(\u0026#34;g\u0026#34;)); EXPECT_TRUE(page.Login()); }  class LoginPage { public: LoginPage(std::shared_ptr\u0026lt;Authenticator\u0026gt; authenticator, const Cookie\u0026amp; cookie) : authenticator_(authenticator), cookie_(cookie) {} bool Login() { return authenticator_.Authenticate(cookie_); } private: std::shared_ptr\u0026lt;Authenticator\u0026gt; authenticator_; Cookie cookie_; }; TEST(LoginPageTest, SimpleFlexibleTest) { LoginPage page(std::make_shared\u0026lt;FakeAuthenticator\u0026gt;(), Cookie(\u0026#34;g\u0026#34;, \u0026#34;xyz123\u0026#34;)); EXPECT_TRUE(page.Login()); }  Exposing dependencies class UpdateBug { public: explicit UpdateBug(std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db) : db_(db) {} void Execute(const Bug\u0026amp; bug) { // Impose internal lock management on client.  db_-\u0026gt;GetLock().Lock(); db_-\u0026gt;Save(bug); db_-\u0026gt;GetLock().Unlock(); } private: std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db_; }; // This test shouldn\u0026#39;t be needed, but we must enforce Lock/Unlock is called // around Save. TEST(UpdateBugTest, HardToTest) { MockLock mock_lock; auto mock_db = std::make_shared\u0026lt;MockDatabase\u0026gt;(); Bug bug(\u0026#34;description\u0026#34;); UpdateBug updateBug(mock_db); EXPECT_CALL(*mock_db, GetLock()).WillRepeatedly(ReturnRef(mock_lock)); { InSequence dummy; EXPECT_CALL(mock_lock, Lock()); EXPECT_CALL(*mock_db, Save(Ref(bug))); EXPECT_CALL(mock_lock, Unlock()); } updateBug.Execute(bug); }  class UpdateBug { public: explicit UpdateBug(std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db) : db_(db) {} void Execute(const Bug\u0026amp; bug) { // Save calls Lock/Unlock internally  db_-\u0026gt;Save(bug); } private: std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db_; }; // Go strait to testing state. No need for mock test since locking interaction // is encapsulated in the database. TEST(UpdateBugTest, EasyTest) { auto db = std::make_shared\u0026lt;FakeDatabase\u0026gt;(); UpdateBug updateBug(); Bug bug(\u0026#34;description\u0026#34;); updateBug.Execute(bug); EXPECT_EQ(bug, db.GetLastSaved()); }  Context Objects class MembershipPlan { // ...  public: void ProcessOrder(UserContext\u0026amp; userContext) { User user = userContext.GetUser(); PlanLevel level = userContext.GetLevel(); Order order = userContext.GetOrder(); // process...  } }; TEST(MembershipPlanTest, BrittleUnreadableTest) { MembershipPlan plan; UserContext userContext; userContext.SetUser(User(\u0026#34;Kim\u0026#34;)); userContext.SetLevel(PlanLevel(143, \u0026#34;yearly\u0026#34;)); userContext.SetOrder(Order(\u0026#34;SuperDeluxe\u0026#34;, 100, true)); // Hopefully this is all the setup the userContext needs to call ProcessOrder  plan.ProcessOrder(userContext); // Make assertions against userContext and plan... }  class MembershipPlan { // ...  public: void ProcessOrder(User\u0026amp; user, Order\u0026amp; order, const PlanLevel\u0026amp; level) { // process...  } }; TEST(MembershipPlanTest, FlexibleSimpleTest) { MembershipPlan plan; User user(\u0026#34;Kim\u0026#34;); Order order(\u0026#34;SuperDeluxe\u0026#34;, 100, true); const PlanLevel level(143, \u0026#34;yearly\u0026#34;); plan.ProcessOrder(user, order, level); // Make assertions against user, order and plan... }  Global State Global state is difficult to understand. Ideally, the interface of an object should fully describe it\u0026rsquo;s dependencies. Global state ruins this ideal because it can be used anywhere without warning. Such flexibility may seem convenient to the original developer, but to others it\u0026rsquo;s confusing. Especially in large code bases, it can be difficult to realize that some global state exists and reason about the circumstances in which it should or shouldn\u0026rsquo;t be used.\nGlobal state is the enemy of testing. It strongly couples itself to the code that uses it. Global scope encourages widespread usage, further compounding coupling issues. Coupling to concrete types makes it impossible to write test doubles and global state must be concrete because it uses the static keyword.\nFixing violations Below are some examples of global state and how they can be fixed with Dependency Injection. However, Dependency Injection alone is often not enough to fix static methods. For those, an adapter called the repository pattern can help remove the static cling.\nNote, the solutions to the examples should not feel good and require a lot of work. It is really tough to test global state. The best solution is to never use it or refactor away from it altogether.\nSingletons class LoginService { public: static LoginService\u0026amp; GetInstance() { static LoginService instance; return instance; } // ... }; class AdminDashboard { public: bool IsAuthenticatedAdmin(const User\u0026amp; user) { return LoginService::GetInstance().IsAuthenticatedAdmin(user); } // ... }; TEST_F(AdminDashboardTest, FlakeySlowAndBrittleTest) { // Forced to use the real LoginService singleton.  User user(\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;); ASSERT_TRUE(adminDashboard_.IsAuthenticatedAdmin(user)); }  class LoginServiceRepository { public: virtual ~LoginServiceRepository() = default; virtual LoginService\u0026amp; GetInstance() = 0; }; class AdminDashboard { public: explicit AdminDashboard(std::shared_ptr\u0026lt;LoginServiceRepository\u0026gt; loginService) : loginService_(loginService) {} bool IsAuthenticatedAdmin(const User\u0026amp; user) { return loginService_-\u0026gt;GetInstance().IsAuthenticatedAdmin(user); } private: std::shared_ptr\u0026lt;LoginServiceRepository\u0026gt; loginService_; }; TEST(AdminDashboardTest, ReliableFastAndFlexibleTest) { // Can now use test doubles for the LoginService singleton.  AdminDashboard adminDashboard(std::make_shared\u0026lt;MockLoginService\u0026gt;()); User user(\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;); ASSERT_TRUE(adminDashboard.IsAuthenticatedAdmin(user)); }  Flags static bool kFlagUseRealBackend; class RpcClient { public: static RpcClient\u0026amp; GetInstance() { static RpcClient instance; return instance; } bool IsReal() { return backend_-\u0026gt;IsReal(); } private: RpcClient() { if (kFlagUseRealBackend) { backend_ = std::make_unique\u0026lt;RealBackend\u0026gt;(); } else { backend_ = std::make_unique\u0026lt;DummyBackend\u0026gt;(); } } //...  std::unique_ptr\u0026lt;Backend\u0026gt; backend_; }; // The 2nd test to run will fail if both tests are run together // because the RpcClient is static.  TEST(RpcClientTest, SmallComplexAndFlakeyTest) { kFlagUseRealBackend = false; RpcClient\u0026amp; client = RpcClient::GetInstance(); EXPECT_FALSE(client.IsReal()); } TEST(RpcClientTest, LargeComplexAndFlakeyTest) { kFlagUseRealBackend = true; RpcClient\u0026amp; client = RpcClient::GetInstance(); EXPECT_TRUE(client.IsReal()); }  class RpcClient { public: explicit RpcClient(std::unique_ptr\u0026lt;Backend\u0026gt; backend) : backend_(std::move(backend)) {} bool IsReal() { return backend_-\u0026gt;IsReal(); } private: std::unique_ptr\u0026lt;Backend\u0026gt; backend_; }; // Now, both tests pass.  TEST(RpcClientTest, SmallSimpleAndReliableTest) { RpcClient client(std::make_unique\u0026lt;DummyBackend\u0026gt;()); EXPECT_FALSE(client.IsReal()); } TEST(RpcClientTest, LargeSimpleAndReliableTest) { RpcClient client(std::make_unique\u0026lt;RealBackend\u0026gt;()); EXPECT_TRUE(client.IsReal()); }  Static methods class TrainSchedule { // ...  std::shared_ptr\u0026lt;Schedule\u0026gt; FindNextTrain() { // ...  // Slow third party service  if (TrackStatus::IsClosed(track)) { // ...  } // ...  return schedule; } } TEST_F(TrainScheduleTest, FlakeySlowAndBrittleTest) { // Forces third party TrackStatus to get called  ASSERT_NE(trainSchedule_.FindNextTrain(), nullptr); }  class TrackStatusRepository { public: virtual ~TrackStatusRepository() = default; virtual bool IsClosed(const Track\u0026amp; track) = 0; }; class RealTrackStatusRepository : public TrackStatusRepository { public: // ... Wrap each of the third party library\u0026#39;s methods.  bool IsClosed(const Track\u0026amp; track) { return TrackStatus::IsClosed(track); } }; class TrainSchedule { public: TrainSchedule(std::unique_ptr\u0026lt;TrackStatusRepository\u0026gt; trackStatus) : trackStatus_(std::move(trackStatus)) {} // ...  std::shared_ptr\u0026lt;Schedule\u0026gt; FindNextTrain() { // ...  if (trackStatus_-\u0026gt;IsClosed(track)) { // ...  } // ...  return schedule; } private: std::unique_ptr\u0026lt;TrackStatusRepository\u0026gt; trackStatus_; }; TEST(TrainScheduleTest, ReliableFastAndFlexibleTest) { // Now TrainSchedule can be tested in isolation.  TrainSchedule trainSchedule(std::make_unique\u0026lt;StubTrackStatusRepository\u0026gt;()); ASSERT_NE(trainSchedule.FindNextTrain(), nullptr); }  Single Responsibility Principle If you have a class that feels like it:\n Contains hidden interactions that make you scratch your head. Is difficult to read and retain in memory. Is difficult to reason about its state or contains a bunch of conditional logic. Is difficult to describe what it does or the word \u0026lsquo;and\u0026rsquo; is used. Requires too many dependencies. Requires too much work to write a test double. Requires too many tests for full coverage. Requires large tests with complex setup/teardown.  Then, that class is likely violating the Single Responsibility Principle. Such classes hide points of flexibility and encapsulate interaction instead of encapsulating behavior. Poor flexibility and encapsulation creates brittle design and strong coupling. The result is a class that\u0026rsquo;s hard to test.\nFixing violations Opportunity to fix a violation of the Single Responsibility Principle is either proactive or reactive, depending on whether the violation is caught before or after it\u0026rsquo;s committed to the codebase.\nIt should go without saying that the proactive approach is less work.\nProactive  Identify the individual responsibilities. Give each responsibility a crisp name. Extract functionality into each class. Celebrate how much easier the class is to test.  Reactive  Extract a class in the place where behavior is being altered with new functionality. Start to move chunks of behavior out of the legacy class and test each chunk in isolation.  static methods are a sign of a homeless method. It likely belongs to one of the parameters it takes.\n "
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/whittaker/",
	"title": "James Whittaker",
	"tags": [],
	"description": "",
	"content": "The Seven Plagues of Software Testing  Aimlessness - Do not test for the sake of testing. Every test should have a goal. Document what works and analyze what doesn\u0026rsquo;t. Then, share with your colleagues.1 Repetitiveness - Running the same test suite over again without finding new bugs does not mean that there are no bugs. Variation is healthy.2 Amnesia - Chances are the problem your are trying to solve has been solved before. If the same issue keeps stinging you, or you had to answer a question the hard way, document it and put it in a place others will find it.3 Boredom - A bored tester rushes through the tactical aspects of testing without considering the interesting strategic aspects. The day testing gets \u0026ldquo;figured out\u0026rdquo; is the day it gets completely automated away.4 Homelessness - Testers are homeless. They don\u0026rsquo;t actually live in the software like users do. Some bugs are only found with the hands of users doing their work in their environment.5 Blindness - Testers require tools to provide helpful feedback from software. It\u0026rsquo;s tempting to settle down with a trusty set of tools, but doing so causes self-inflicted blindness to a growing ecosystem of useful feedback.6 Entropy - Testers increase entropy by giving developers things to do. This is unavoidable, but preventative. As developers do more during development, testers add less work, and entropy tends towards a minimum.7  An Ingredients List for Testing  Product expertise - A good developer knows how the product works; a good tester knows how to use it.8 Bill of materials - Testers should be able to reference a complete list of features that can be tested.9 Risk analysis - Features are not equally important, or equally time consuming to test. Have a model to quantitatively analyze the risk of each feature.10 Domain expertise - It is not enough to be good at testing. Testers also need expertise with the technologies of the domain the product operates in.11 Test guidance - Whether it be technique, nomenclature, or history, testers need a way to identify and store tribal knowledge of the team.12 Variation - Tests often get stale. Wasting time running stale tests is also a form of risk. Adding variation can breathe new life into stale tests.13 Completeness analysis - Teams need a model to measure how well their testing efforts have covered the risk landscape of their product.14  How Google Tests Software Engineers are loaned out to product teams on an as-needed basis. Engineers are free to change product teams at their own cadence.15\nDevelopers own quality while testers support developers with tools and feedback. As developers get better at testing, less testers are needed. Successful teams have higher developer-to-tester ratios. 15\nDevelopment and test are not treated as separate disciplines. Developers test and testers code.16 Instead, each of the three roles look at the product from different angles:\n SWE (Software Engineer) - Feature creators responsible for their work. SWEs design and write features, and then prove they work by writing and running tests. SET (Software Engineer in Test) - Codebase caretakers who enable SWEs to write tests. SETs refactor code for testability, and write test features including test doubles and test framework. TE (Test Engineer) - Product experts who analyze quality and risk from the perspective of the user. TEs write large tests and automation scrips as well as drive test execution and interpret their results.17  SETs and TEs\u0026rsquo; are usually not involved early in the design phase of a product. Only when the product gains traction do they begin to exert their influence.18 19\nSETs and SWEs have similar skill sets. Conversions from one role to another are common.20\nQuality is a work in progress that relies on getting product out to users and receiving feedback as quickly as possible. As its being developed, a release is pushed through several channels in order of increasing confidence in quality:\n Canary - Only fit for ultra tolerant users running experiments. Dev - Used by developers for day-to-day work. Test - Used internally for day-to-day work. Beta/Release - Fit for external exposure.10  Tests are classified by scope, falling under three categories:\n Small - Covers a single function, focusing on logic. Medium - Covers a function and its nearest neighbors, focusing on interoperability. Large - Covers an entire user scenario, focusing on business requirements.21  If a test doesn\u0026rsquo;t require human cleverness or intuition, it is automated. Bug reporting is automated too.21\n  https://testing.googleblog.com/2009/06/7-plagues-of-software-testing.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/06/by-james.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-amnesia.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-boredom.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-homelessness.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-blindness.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/09/plague-of-entropy.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/08/ingredients-list-for-testing-part-one.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/08/ingredients-list-for-testing-part-two.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/03/how-google-tests-software-part-four.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/09/ingredients-list-for-testing-part-four.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/10/ingredients-list-for-testing-part-five.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/11/ingredients-list-for-testing-part-six.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/11/ingredients-list-for-testing-part-seven.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/01/how-google-tests-software.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/02/how-google-tests-software-part-three.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/02/how-google-tests-software-part-two.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/05/how-google-tests-software-part-six.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/05/how-google-tests-software-part-seven.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/05/how-google-tests-software-break-for-q.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/03/how-google-tests-software-part-five.html \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://ajguerrer.github.io/",
	"title": "Notebook",
	"tags": [],
	"description": "",
	"content": "Andrew Guerrero Notebook Welcome! You have stumbled upon Andrew Guerrero\u0026rsquo;s notebook.\nIf you are looking for notes on software engineering, then you have come to the right place!\n "
},
{
	"uri": "https://ajguerrer.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/tott/",
	"title": "Testing on the Toilet",
	"tags": [],
	"description": "",
	"content": "This page contains potable bits of testing best-practices that will keep you riveted to your seat.\nTests Too DRY? Make Them DAMP! December 03, 2019 - original post\nThough the DRY (\u0026ldquo;Don\u0026rsquo;t Repeat Yourself\u0026rdquo;) principle is great for production code, tests don\u0026rsquo;t test themselves.\nclass ForumTest : public ::testing::Test { protected: void SetUp() override { for (auto user : users_) { forum_.Register(user); } } Forum forum_; std::vector\u0026lt;User\u0026gt; users_ = {User(\u0026#34;Alice\u0026#34;), User(\u0026#34;Bob\u0026#34;)}; } TEST_F(ForumTest, CanRegisterMultipleUsers) { for (auto user : users_) { EXPECT_TRUE(forum_.HasRegisteredUser(user)); } }  Tests should optimize for readability, even at the expense of redundancy. Prefer the DAMP (\u0026ldquo;Descriptive and Meaningful Phrases\u0026rdquo;) principle.\nTEST(ForumTest, CanRegisterMultipleUsers) { Forum forum; User user1(\u0026#34;Alice\u0026#34;); User user2(\u0026#34;Bob\u0026#34;); forum.Register(user1); forum.Register(user2); EXPECT_TRUE(forum.HasRegisteredUser(user1)); EXPECT_TRUE(forum.HasRegisteredUser(user2)); }  Exercise Service Call Contracts in Tests November 27, 2018 - original post\nIf the code under test relies on the contract of a service, prefer exercising the service call instead of mocking it out. Some service owners provide a fake. Otherwise, use a hermetic server.\nMake Interfaces Hard to Misuse July 25, 2018 - original post\nDon\u0026rsquo;t push the responsibility of maintaining invariants on the caller.\nclass Vector { explicit Vector(int num_slots); int RemainingSlots() const; void AddSlots(int num_slots); void Insert(int value); };  In the code above, the caller needs to check RemainingSlots, and if 0, AddSlots in order for Insert to work properly.\nInstead, Insert could automatically manage slots.\nclass Vector { explicit Vector(int num_slots); void Insert(int value); };  Other signs an interface is hard to use:\n Initialize / Deitialize functions. Allowing partially created objects. Parameters that can have invalid values.  Sometimes it\u0026rsquo;s not practical to have a foolproof interface. In those cases rely on static analysis or documentation.\nOnly Verify Relevant Method Arguments June 26, 2018 - original post\nTests become fragile when they expect exact values on irrelevant arguments.\nTEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fake_clock_.SetTime(kNewYearsDay); fake_user_.SetName(\u0026#34;Fake User\u0026#34;); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(\u0026#34;Hi Fake User! Happy New Year!\u0026#34;, TitleBar(\u0026#34;2018-01-01\u0026#34;), PromptStyle::kNormal)); user_greeter_.DisplayGreeting(); }   Only verify one behavior per test. Only verify arguments that affect the correctness of the specific behavior being tested.  TEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fake_clock_.SetTime(kNewYearsDay); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(\u0026#34;Happy New Year!\u0026#34;), _, _)); user_greeter_.DisplayGreeting(); } TEST_F(DisplayGreetingTest, RenderUserName) { fake_user_.SetName(\u0026#34;Fake User\u0026#34;); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(\u0026#34;Fake User\u0026#34;), _, _)); user_greeter_.DisplayGreeting(); }  Keep Tests Focused June 11, 2018 - original post\nTesting too many scenarios at once can make it difficult to understand test and reason about the failure.\nTEST_F(BankAccountTest, WithdrawFromAccount) { Transaction transaction = account_.Deposit(Usd(5)); clock_.AdvanceTime(kMinTimeToSettle); account_.Settle(transaction); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); EXPECT_THAT(account_.Withdraw(USd(1)), IsRejected()); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(1)), IsOk()); }  Break up each scenario into its own test.\nTEST_F(BankAccountTest, CanWithdrawWithinBalance) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); } TEST_F(BankAccountTest, CannotOverdraw) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsRejected()); } TEST_F(BankAccountTest, CanOverdrawUpToOverdraftLimit) { DepositAndSettle(Usd(5)); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsOk()); }  Notice how each test only verifies the output of one call per test.\nUnderstanding Code in Review May 1, 2018 - original post\nIf you find yourself reviewing code that is difficult to understand, don\u0026rsquo;t waste time reviewing it.\nbool IsOkay(int n) { bool f = false; for (int i = 2; i \u0026lt;= n; ++i) { if (n % i == 0) f = true; } return !f; }  Ask for it to be clarified.\nbool IsPrime(int n) { for (int divisor = 2; divisor \u0026lt;= n / 2; ++divisor) { if (n % divisor == 0) return false; } return true; }  Clarifying code often results in noticing improvements.\nCleanly Create Test Data February 20, 2018 - original post\nHelper methods make it easier to create test data, but they don\u0026rsquo;t age well.\n// Starts simple Company company = NewCompany(kPublic); // But soon acquires more parameters Company small = NewCompany(2, 2, nullptr, kPublic); Company privately_owned = NewCompany(0, 0, nullptr, kPrivate); Company bankrupt = NewCompany(0 , 0, kPastDate, kPublic); // Or more methods Company small = NewCompanyWithEmployeesAndBoardMembers(2, 2, kPublic); Company privately_owned = NewCompanyWithType(kPrivate); Company bankrupt = NewCompanyWithBankruptcyDate(kPastDate, kPublic);  Try the builder pattern.\nCompany small = Company::Builder{}.SetEmployees(2).SetBoardMembers(2).Build(); Company privately_owned = Company::Builder{}.SetType(kPrivate).Build(); Company bankrupt = Company::Builder{}.SetBankruptcyDate(kPastDate).Build(); Company default_company = Company::Builder{}.Build(); class Company::Builder { public: Builder\u0026amp; SetEmployees(int n) { employees_ = n; return *this; } Builder\u0026amp; SetBoardMembers(int n) { board_members_ = n; return *this; } Builder\u0026amp; SetBankruptcyDate(BankruptcyDate d) { date_ = d; return *this; } Builder\u0026amp; SetType(Type t) { type_ = t; return *this; } Company Build() const { return Company(employees_, board_members_, date_, type_); } private: int employees_ = 0; int board_members_ = 0; BankruptcyDate date_ = kBeforeDate; Type type_ = kPublic; };  Only Expect State-Changing Method Calls December 11, 2017 - original post\nExpecting calls to methods that don\u0026rsquo;t change state can make a test brittle, less readable, and provide a false sense of security.\nTEST(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_user_service_, IsUserActive(kUser); EXPECT_CALL(mock_permission_db_, GetPermission(kUser); EXPECT_CALL(mock_permission_db_, IsValidPermission(kReadAccess); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }  It is fine, however, to use non-state-changing methods for simulating test conditions.\nON_CALL(mock_user_service_, IsUserActive(kUser)).WillByDefault(Return(false));  With unnecessary EXPECT_CALLs removed, the test becomes:\nTest(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }  Obsessed With Primitives? November 14, 2017 - original post\nCode that relies too heavily on primitive types instead of custom abstractions can be hard to understand and maintain.\nstd::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; polygon = { std::make_pair(0, 0), std::make_pair(0, 4), std::make_pair(4, 0) }; std::pair\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::pair\u0026lt;int, int\u0026gt;\u0026gt; bounding_box = GetBoundingBox(polygon); int area = (bounding_box.second.first - bounding_box.first.first) * (bounding_box.second.second - bounding_box.first.second);  Make higher-level abstractions.\nPolygon polygon = RightTriangle(4, 4); int area = polygon.GetBoundingBox().GetArea();  This advice doesn\u0026rsquo;t just apply to primitives and The STL. It\u0026rsquo;s possible for any type to be too primitive for the job.\nPolygon polygon = IsoscelesRightTriangle(4); int area = polygon.GetBoundingBox().GetArea();  IdentifierNamingPostForWorldWideWebBlog October 23, 2017 - original post\nNames should be clear and precise.\nDon\u0026rsquo;t mention the type in the variable name. It\u0026rsquo;s OK for the name and the type match.\nstd::string name_string; std::list\u0026lt;std::time_t\u0026gt; holiday_date_list;  std::string name; std::list\u0026lt;std::time_t\u0026gt; holidays; Payments payments;  Don\u0026rsquo;t use overly specific names. Get more specific if there is a need for disambiguation.\nMonster final_battle_most_dangerous_boss_monster; Payments non_typical_monthly_payments;  Monster boss; Payments payments;  Do not repeat context.\nclass AnnualHolidaySale { bool PromoteHolidaySale(); int annual_sale_rebate_; };  class AnnualHolidaySale { bool Promote(); int rebate_; }  To Comment or Not to Comment July 17, 2017 - original post\nComments are not always helpful.\n// Subtract discount from final price. final_price = (num_items * item_price) - std::min(5, num_items) * item_price * 0.1; // Filter offensive words. for (std::string word : words) { ... } int width = ...; // Width in pixels.  // Safe since height is always \u0026gt; 0. return width / height;  It\u0026rsquo;s often better to make your code self-explanatory.\nprice = num_items * item_price; discount = std::min(5, num_items) * item_price * 0.1; final_price = price - discount; FilterOffensiveWords(words); Pixels width = ...; CheckArgument(height \u0026gt; 0); return width / height;  Avoid using comments to explain what code does. Use comments to explain why code does something.\nToo Many Comments on Your Code Reviews? June 19, 2017 - original post\nBefore you send out the code review:\n Review your own code first. Discuss with colleagues. Make bite-sized reviews. Add comments to the code if necessary.  When addressing code review comments:\n Review your code after addressing non-trivial comments. Understand the reviews thought process. Answer questions in the code.  Reduce Nesting, Reduce Complexity June 15, 2017 - original post\nDeeply nested code is error-prone and hurts readability.\nResponse response = server.Call(request); if (response.GetStatus() == Status::kOk) { if (!IsAuthorized(response.GetUser())) { if (response.GetEnc() == \u0026#34;utf-8\u0026#34;) { std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (!rows.empty()) { avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg; } else { throw EmptyException(); } else { throw AuthException(\u0026#39;unauthorized\u0026#39;); } } else { throw ValueException(\u0026#39;wrong encoding\u0026#39;); } } else { throw RpcException(response.GetStatus()); }  The code above could be refactored to use guard clauses.\nResponse response = server.Call(request); if (response.GetStatus() != Status::kOk) { throw RpcException(response.GetStatus()); } if (!IsAuthorized(response.GetUser())) { throw ValueException(\u0026#39;wrong encoding\u0026#39;); } if (response.GetEnc() != \u0026#34;utf-8\u0026#34;) { throw AuthException(\u0026#39;unauthorized\u0026#39;); } std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (rows.empty()) { throw EmptyException(); } avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg;  Can you spot the bug now?\nKeep Cause and Effect Clear January 31, 2017 - original post\nIt\u0026rsquo;s difficult to reason about a test when the cause is hidden far away from the effect.\nclass TallyTest : public ::testing::Test { protected: void SetUp() override { tally_.Increment(\u0026#34;key1\u0026#34;, 8); tally_.Increment(\u0026#34;key2\u0026#34;, 100); tally_.Increment(\u0026#34;key1\u0026#34;, 0); tally_.Increment(\u0026#34;key1\u0026#34;, 1); } Tally tally_; } // 200 lines of code  TEST_F(TallyTest, IncrementExistingKey) { EXPECT_EQ(9, tally_.Get(\u0026#34;key1\u0026#34;)); }  Write tests where the effects immediately follow the causes.\nclass TallyTest : public ::testing::Test { protected: Tally tally_; } TEST_F(TallyTest, NewKey) { tally_.Increment(\u0026#34;key\u0026#34;, 100); EXPECT_EQ(100, tally_.Get(\u0026#34;key\u0026#34;)); } TEST_F(TallyTest, ExistingKey) { tally_.Increment(\u0026#34;key\u0026#34;, 8); tally_.Increment(\u0026#34;key\u0026#34;, 1); EXPECT_EQ(9, tally_.Get(\u0026#34;key\u0026#34;)); } TEST_F(TallyTest, IncrementByZeroDoesNothing) { tally_.Increment(\u0026#34;key\u0026#34;, 8); tally_.Increment(\u0026#34;key\u0026#34;, 0); EXPECT_EQ(8, tally_.Get(\u0026#34;key\u0026#34;)); }  It may require a bit more code, but it\u0026rsquo;s easier to read and maintain.\nWhat Makes a Good End-to-End Test? September, 2016 - original post\nEnd-to-end tests give confidence about the health of the system when it is in a near production state, but they tend to be more flaky and expensive to maintain.\nTo be cost effective, end-to-end tests should focus on aspects of the system that cannot be evaluated by smaller tests. Minor and/or frequently changing details like error messages or visual layouts should not effect the test.\nChange-Detector Tests Considered Harmful January 27, 2015 - original post\nTests that break in response to any change to production code without verifying correct behavior only add to maintenance costs without catching defects.\nvoid Processor::Process(Work w) { first_part_.Process(w); second_part_.Process(w); } TEST(ProcessorTest, ProcessWork) { MockFirstPart part1; MockSecondPart part2; Processor p(part1, part2); Work w; EXPECT_CALL(part1, Process(w)); EXPECT_CALL(part2, Process(w)); p.Process(w); }  Tests like these should either be re-written or deleted.\nPrefer Testing Public APIs Over Implementation-Detail Classes January 14, 2015 - original post\nPublic APIs can be called by many users. Implementation details are only called by public APIs. If the public APIs are well tested, as they should be, then the implementation details will get tested by association.\nHeavy testing against implementation details can cause a couple problems:\n Unlike public APIs, implementation details are vulnerable to refactoring. Tests for implementation details can fail even though the behavior from the public API is fine. Testing implementation details can give false confidence. Even if an implementation detail is well tested, that doesn\u0026rsquo;t mean the pubic API behaves properly.  Writing Descriptive Test Names October 16, 2014 - original post\nVague test names make it hard to keep track of what is tested.\nTEST_F(IsUserLockedOutTest, InvalidLogin) { authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_TRUE(authenticator_.IsUserLockedOut(username_)); }  Descriptive test names make it easy to tell what behavior is broken without looking at code. Also, the length of a good test name helps indicate when a test needs to be split apart.\nTEST_F(IsUserLockedOutTest, ShouldLockOutUserAfterThreeInvalidLoginAttempts) { // ... }  A test\u0026rsquo;s name should be all you need to know to understand the behavior being tested. Make sure the name contains both the scenario being tested and the expected outcome.\nDon\u0026rsquo;t Put Logic in Tests July 31, 2014 - original post\nTests should be simple by stating I/O directly rather than computing them.\nTEST(NavigatorTest, ShouldNavigateToPhotosPage) { const std::string baseUrl = \u0026#34;http://plus.google.com/\u0026#34;; Navigator nav(baseUrl); nav.GoToPhotosPage(); EXPECT_EQ(baseUrl + \u0026#34;/u/0/photos\u0026#34;, nav.GetCurrentUrl()); }  Even a simple string concatenation can lead to bugs.\nTEST(NavigatorTest, ShouldNavigateToPhotosPage) { Navigator nav(\u0026#34;http://plug.google.com/\u0026#34;); nav.GoToPhotosPage(); EXPECT_EQ(\u0026#34;http://plus.google.com//u/0/photos\u0026#34;, nav.GetCurrentUrl()); }  If a test requires logic, move that logic out of the test body into utilities and helper functions and write tests for them too.\nRisk-Driven Testing May 30, 2014 - original post\nBlindly writing tests can lead to a false sense of security or wasted effort. Before writing tests, think about testing. Small tests are cheap, larger tests protect core use-cases and integration. Manual testing can sometimes be the cheapest, most effective option.\nEffective Testing May 7, 2014 - original post\nTo be effective, a test maximizes three important qualities:\n Fidelity - Sensitive to defects in the code under test. Resilience - Fails only when a breaking change is made to the code under test. Precision - Upon failure reports exactly where the defect lies.  Test Behaviors, Not Methods A single method can exhibit many behaviors. Likewise, a single behavior can span multiple methods.\nIt can be harmful to think that tests and public methods should have a 1:1 relationship.\nTEST_F(TransactionProcessorTest, ProcessTransaction) { User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2)); transaction_processor_.ProcessTransaction(user, Transaction(\u0026#34;Pile of Beanie Babies\u0026#34;, Dollars(3))); EXPECT_THAT(ui_.GetText(), HasSubstr(\u0026#34;You bought a Pile of Beanie Babies\u0026#34;)); EXPECT_EQ(user.GetEmails().size(), 1); EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), \u0026#34;Your balance is low\u0026#34;); }  Each test should verify one behavior. Each method may take several tests to verify.\nTEST_F(TransactionProcessorTest, ShouldDisplayNotification) { transaction_processor_.ProcessTransaction(User(), Transaction(\u0026#34;Pile of Beanie Babies\u0026#34;)); EXPECT_THAT(ui_.GetText(), HasSubstr(\u0026#34;You bought a Pile of Beanie Babies\u0026#34;)); } TEST_F(TransactionProcessorTest, ShouldSendEmailWhenBalanceIsLow) { User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2)); transaction_processor_.ProcessTransaction(user, Transaction(Dollars(3))); EXPECT_EQ(user.GetEmails().size(), 1); EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), \u0026#34;Your balance is low\u0026#34;); }  What Makes a Good Test? Tests provide more than verification. They also serve as documentation.\nAs a source of documentation, test should not be distracting or hide information.\nTEST(CalculatorTest, ShouldPerformAddition) { Calculator calculator(RoundingStrategy(), \u0026#34;unused\u0026#34;, kEnableCosinFeature, 0.01, kCalculusEngine, false); int result = calculator.DoComputation(MakeTestComputation()); EXPECT_EQ(result, 5); }  TEST_(CalculatorTest, ShouldPerformAddition) { const int result = calculator_.DoComputation(MakeAdditionComputation(2, 3)); EXPECT_EQ(result, 5); }  Test Behavior, Not Implementation August 5, 2013 - original post\nExcept where explicitly intended, tests should work independent of the implementation details being tested.\nclass Calculator { public: int Add(int a, int b) { return a + b; } }; class Calculator { public: int Add(int a, int b) { Adder adder = adder_factory_.CreateAdder(); ReturnValue return_value = adder.Compute(Number(a), Number(b)); return return_value.ConvertToInteger(); } private: AdderFactory adder_factory_; }; TEST_F(CalculatorTest, ShouldAddIntegers) { EXPECT_EQ(3, calculator_.Add(2, 1)); EXPECT_EQ(2, calculator_.Add(2, 0)); EXPECT_EQ(1, calculator_.Add(2, -1)); } Know Your Test Doubles July 18, 2013 - original post\nA test double is an object that can stand in for a real object in test. The most common types of test doubles are:\n  Stub - Returns a specific values to promote a specific state.\nAccessManager access_manager(kStubAuthenticationService); ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(false)); EXPECT_FALSE(access_manager.UserHasAccess(kUserId)); ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(true)); EXPECT_TRUE(access_manager.UserHasAccess(kUserId));   Mock - Sets expectations about how other objects should interact with it.\nAccessManager access_manager(mockAuthenticationService); EXPECT_CALL(mockAuthenticationService, IsAuthenticated(kUserId)); access_manager.UserHasAccess(kUserId);   Fake - A lightweight implementation when the real implementation is unsuitable for test.\nFakeAuthenticationService fake_authentication_service; AccessManager access_manager(fake_authentication_service); EXPECT_FALSE(access_manager.UserHasAccess(kUserId)); fake_authentication_service.AddAuthenticatedUser(kUser); EXPECT_TRUE(access_manager.UserHasAccess(kUserId));   Fake Your Way To Better Tests June 28, 2013 - original post\nSuppose you would like to test your blog platform API, but you don\u0026rsquo;t want your tests talking to a remote server.\nvoid DeletePostsWithTag(const Tag\u0026amp; tag) { for (const Post post : blog_service_-\u0026gt;GetAllPosts()) { if (post.HasTag(tag)) { blog_service_-\u0026gt;DeletePost(post.GetId()); } } } A fake is a lightweight implementation of an API that behaves like the real implementation, but isn\u0026rsquo;t suitable for production.\nclass FakeBlogService : public BlogService { public: void AddPost(const Post\u0026amp; post) { posts.insert(post); } void DeletePost(const int id) { for (auto\u0026amp; post : posts) { if (post.GetId() == id) { posts.erase(post); return; } } } std::set\u0026lt;Post\u0026gt; GetAllPosts() const { return posts; } private: std::set\u0026lt;Post\u0026gt; posts; }; Fakes should be created and maintained by the person or team that owns the real implementation.\nFakes should have their own tests to make sure they behave like the real implementation.\nDon\u0026rsquo;t Overuse Mocks May 28, 2013 - original post\nMocks are powerful, but easy to abuse.\nTEST_F(PaymentProcessorTest, ShouldChargeCreditCard) { PaymentProcessor payment_processor(mock_credit_card_server_); InSequence s; EXPECT_CALL(mock_credit_card_server_, IsServerAvailable()).WillOnce(Return(true)); EXPECT_CALL(mock_credit_card_server_, BeginTransaction()).WillOnce(Return(mock_transaction_manager_)); EXPECT_CALL(mock_transaction_manager_, GetTransaction()).WillOnce(Return(transaction_)); EXPECT_CALL(mock_credit_card_server_, Pay(transaction_, credit_card_, 500)).WillOnce(Return(mock_payment_)); EXPECT_CALL(mock_payment_, IsOverMaxBalance()).WillOnce(Return(false)); payment_processor.ProcessPayment(credit_card_, Dollars(500)); }  Overusing mocks makes tests harder to understand, maintain, and provides less insurance that your code is working properly.\nIf you don\u0026rsquo;t need a mock, don\u0026rsquo;t use one. Understanding when to use a mock comes from understanding what you want to test.\nTEST_F(PaymentProcessorTest, ShouldChargeCreditCard) { PaymentProcessor payment_processor(credit_card_server_); payment_processor.ProcessPayment(credit_card_, Dollars(500)); EXPECT_EQ(credit_card_server_.GetMostRecentCharge(credit_card_), 500); }  Testing State vs. Testing Interactions March 22, 2013 - original post\n  Testing State - Verifying the code under test returns the correct results.\nTEST(NumberSorterTest, ShouldSortIntegers) { NumberSorter number_sorter({quicksort, bubblesort}); std::vector\u0026lt;int\u0026gt; numbers = {3, 1, 2}; EXPECT_EQ({1, 2, 3}, number_sorter.SortNumbers(numbers)); }   Testing Interaction - Verifying the code under test calls methods correctly.\nTEST(NumberSorterTest, ShouldUseQuicksort) { NumberSorter number_sorter({mock_quicksort, mock_bubblesort}); std::vector\u0026lt;int\u0026gt; numbers = {3, 1, 2}; EXPECT_CALL(mock_quicksort, Sort(numbers); number_sorter.SortNumbers(numbers); }   Most of the time you want to test state. Occasionally interactions need to be tested when the number of calls or order of calls matter.\nCode coverage goal: 80% and no less! July 20, 2010 - original post\nEarly one morning, a young programmer asked the great master, “I am ready to write some unit tests. What code coverage should I aim for?”\nThe great master replied, “Don’t worry about coverage, just write some good tests.”\nThe young programmer smiled, bowed, and left.\nLater that day, a second programmer asked the same question. The great master pointed at a pot of boiling water and asked, “How many grains of rice should I put in that pot?”\nThe programmer, looking puzzled, replied, “How can I possibly tell you? It depends on how many people you need to feed, how hungry they are, what other food you are serving, how much rice you have available, and so on.”\n“Exactly,” said the great master.\nThe second programmer smiled, bowed, and left.\nToward the end of the day, a third programmer came and asked the same question about code coverage.\n“Eighty percent and no less!” Replied the master in a stern voice, pounding his fist on the table.\nThe third programmer smiled, bowed, and left.\nAfter this last reply, a young apprentice approached the great master, “Great master, today I overheard you answer the same question about code coverage with three different answers. Why?”\nThe great master stood up from his chair. “Come get some fresh tea with me and let’s talk about it.” After they filled their cups with smoking hot green tea, the great master began:\n“The first programmer is new and just getting started with testing. Right now he has a lot of code and no tests. He has a long way to go; focusing on code coverage at this time would be depressing and quite useless. He’s better off just getting used to writing and running some tests. He can worry about coverage later.\n\u0026ldquo;The second programmer, on the other hand, is quite experienced both at programming and testing. When I replied by asking her how many grains of rice I should put in a pot, I helped her realize that the amount of testing necessary depends on a number of factors, and she knows those factors better than I do – it’s her code after all. There is no single, simple, answer, and she’s smart enough to handle the truth and work with that.”\n“I see,” said the young apprentice, “but if there is no single simple answer, then why did you tell the third programmer ‘Eighty percent and no less’?”\nThe great master laughed so hard and loud that his belly, evidence that he drank more than just green tea, flopped up and down. “The third programmer wants only simple answers – even when there are no simple answers … and then does not follow them anyway.”\nThe young apprentice and the grizzled great master finished drinking their tea in contemplative silence.\nData Driven Traps! September 4, 2008 - original post\nData driven tests are efficient, but easy to abuse.\nstruct TestData { const std::string word; const bool is_word; }; const std::vector\u0026lt;TestData\u0026gt; test_data = { {\u0026#34;milk\u0026#34;, true}, {\u0026#34;centre\u0026#34;, false}, {\u0026#34;jklm\u0026#34;, false}, }; TEST(IsWordTest, TestEverything) { for (const auto\u0026amp; entry : test_data) { EXPECT_EQ(IsWord(entry.word), entry.is_word); } }  Data-driven tests make debugging and understanding failures, let alone false positives, more difficult.\nAs the code grows in complexity, data tends to grow even faster. It quickly becomes impossible to discern what behavior each piece of data is meant to test.\nconst std::vector\u0026lt;Locale\u0026gt; locales = { Word::US, Word::UK, Word::France, ... }; struct TestData { std::string word; bool[kNumLocales] is_word; }; const std::vector\u0026lt;TestData\u0026gt; test_data = { {\u0026#34;milk\u0026#34;, {true, true, false, ...}, {\u0026#34;centre\u0026#34;, {false, true, true, ...}}, {\u0026#34;jklm\u0026#34;, {false, false, false, ...}}, }; TEST(IsWordTest, TestEverything) { for (const auto\u0026amp; entry : test_data) { for (const auto* locale: locales) { EXPECT_EQ(IsWord(entry.word, locale), entry.is_word); } } }  Instead, think critically about what behaviors are worth testing.\nTEST(IsWordTest, ShouldExistInMultipleLocales) { EXPECT_TRUE(IsWord(\u0026#34;milk\u0026#34;, Word::US)); EXPECT_TRUE(IsWord(\u0026#34;milk\u0026#34;, Word::UK)); EXPECT_FALSE(IsWord(\u0026#34;milk\u0026#34;, Word::France)); } TEST(IsWordTest, ShouldNotExist) { // \u0026#34;jklm\u0026#34; test not repeated as it uses the same code path  EXPECT_FALSE(IsWord(\u0026#34;jklm\u0026#34;, Word::US)); }  Sleeping != Synchronization August 21, 2008 - original post\nBeware of sleep. sleep should never be used for synchronization, or in test.\nclass CoffeeMaker { public: virtual ~CoffeeMaker() = default; virtual void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) = 0; }; class Intern : public CoffeeMaker { public: void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) { // make coffee, hopefully within 60 seconds.  callback(); } }; class Employee { public: void DrinkCoffee() { caffeinated_ = true; } bool IsCaffeinated() { return caffeinated_; } void DemandCoffee(CoffeeMaker\u0026amp; cm) { std::thread t(\u0026amp;CoffeeMaker::MakeCoffee, \u0026amp;cm, std::bind(\u0026amp;Employee::DrinkCoffee, this)); t.detach(); } private: bool caffeinated_ = false; }; TEST(EmployeeTest, ShouldBeCaffeinatedOnlyAfterDrinkingCoffee) { Employee e; Intern i; e.DemandCoffee(i); EXPECT_FALSE(e.IsCaffeinated()); std::this_thread::sleep_for(60s); EXPECT_TRUE(e.IsCaffeinated()); }  Code that sleeps can be improved by waiting on a std::future or a std::condition_variable. As always, if your waiting on a non-trivial operation, like Intern::MakeCoffee, use a fake.\nclass FakeIntern : public CoffeeMaker { public: void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mut_); cv_.wait(lock, [this] { return ready_; }); callback(); done_ = true; lock.unlock(); cv_.notify_one(); } void SignalAndWait() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mut_); ready_ = true; cv_.notify_one(); cv_.wait(lock, [this] { return done_; }); } private: bool ready_ = false; bool done_ = false; std::condition_variable cv_; std::mutex mut_; }; TEST(EmployeeTest, ShouldBeCaffeinatedOnlyAfterDrinkingCoffee) { Employee e; FakeIntern i; e.DemandCoffee(i); EXPECT_FALSE(e.IsCaffeinated()); i.SignalAndWait(); EXPECT_TRUE(e.IsCaffeinated()); }  Defeat \u0026ldquo;Static Cling\u0026rdquo; June 26, 2008 - original post\nStatic functions, like this singleton GetInstance method, are a sign of tight coupling.\nclass MyObject { public: int DoSomething(int id) { return TheirEntity::GetInstance().GetSomething(id); } }; There is a way around this using the Repository Pattern.\nclass TheirEntityRepository { public: virtual ~TheirEntityRepository() = default; virtual TheirEntity\u0026amp; GetInstance() = 0; // Other static methods here }; class TheirEntityStaticRepository : public TheirEntityRepository { public: TheirEntity\u0026amp; GetInstance() { return TheirEntity::GetInstance(); } }; class MyObject { public: explicit MyObject(std::unique_ptr\u0026lt;TheirEntityRepository\u0026gt; repository) : repository_(std::move(repository)) {} int DoSomething(int id) { return repository_-\u0026gt;GetInstance().GetSomething(); } private: std::unique_ptr\u0026lt;TheirEntityRepository\u0026gt; repository_; }; All thats left is to derive a MockTheirEntityRepository suitable for your testing needs.\nTestable Contracts Make Exceptional Neighbors May 28, 2008 - original post\nModify external visible state only after completing all operations which could possibly fail.\nbool SomeCollection::GetObjects(std::vector\u0026lt;Object\u0026gt;\u0026amp; objects) const { objects.clear(); for (const auto\u0026amp; object : collection_) { if (object.IsFubarred()) return false; objects.push_back(object); } return true; }  In these situations, the swap trick comes in handy.\nbool SomeCollection::GetObjects(std::vector\u0026lt;Object\u0026gt;\u0026amp; objects) const { std::vector\u0026lt;Object\u0026gt; known_good_objects; for (const auto\u0026amp; object : collection_) { if (object.IsFubarred()) return false; known_good_objects.push_back(object); } objects.swap(known_good_objects); return true; }  Now, the caller has good objects on success, or unchanged objects on failure.\nUnderstanding Your Coverage Data March 6, 2008 - original post\nHigh test coverage is necessary but not sufficient.\nUse your test coverage results to look for unexpected coverage patterns, which usually indicate bugs, and add test cases to address them.\nToo Many Tests February 21, 2008 - original post\nHow many tests? Answering this question requires a good grasp of the context.\nvoid Decide(int32_t a, int32_t b, int32_t c, int32_t d, int32_t e, int32_t d) { if (a \u0026gt; b || c \u0026gt; d || e \u0026gt; f) { DoOneThing(); } else { DoAnother(); } }  Testing every possible input would require 2192 tests. Thats too many. Testing enough to get full line coverage would require 2 tests. Thats too few. Testing each logical expression (e.g a \u0026gt; b, a == b, a \u0026lt; b) independently is 27 tests. Still probably too many.  More context can focus the decision.\nvoid Decide(int32_t a, int32_t b, int32_t c, int32_t d, int32_t e, int32_t d) { if (TallerThan(a, b) || HarderThan(c, d) || HeavierThan(e, f)) { DoOneThing(); } else { DoAnother(); } } bool TallerThan(int32_t a, int32_t b) { return a \u0026gt; b; } bool HarderThan(int32_t c, int32_t d) { return d \u0026gt; d; } bool HeavierThan(int32_t e, int32_t f) { return e \u0026gt; f; } Testing the cases where each extracted function is true, they all are false, and writing 2 tests for each of the extracted functions would require 4 + 3*2 = 10 tests. Considering the number of inputs, thats just enough tests.\nAvoiding Friend Twister in C++ October 30, 2007 - original post\n\u0026ldquo;Testing private members requires more friend contortions than a game of Twister®.\u0026rdquo;\nIf you find yourself saying that, theres a better way.\n// include/my_project/dashboard.h  class Dashboard { private: // Declaration of functions getResults(), GetResultsFromCache(),  // GetResultsFromDatabase(), and CountPassFail()  std::unique_ptr\u0026lt;Database\u0026gt; database_; // instantiated in constructor  friend class DashboardTest; // one friend declaration per test fixture };  Instead, make a helper class by extracting a helper class (a variant of the Pimple idiom).\nTo preserve privacy, the helper class is tucked away in a private implementation directory separate from the public API.\n// include/my_project/dashboard.h  class ResultsLog; // Foreword declare extracted helper interface  class Dashboard { public: explicit Dashboard(std::unique_ptr\u0026lt;ResultsLog\u0026gt; results) : results_(std::move(results)) {} private: std::unique_ptr\u0026lt;ResultsLog\u0026gt; results_; }; // src/results_log.h  class ResultsLog { public: // Declaration of functions getResults(), GetResultsFromCache(),  // GetResultsFromDatabase(), and CountPassFail() }; // src/live_results_log.h  class LiveResultsLog : public ResultsLog { public: explicit LiveResultsLog(std::unique\u0026lt;Database\u0026gt; database) : database_(std::move(database)) {} };  As an added bonus, now you can inject a MockResultsLog or a FakeDatabase for testing the Dashboard class.\nRefactoring Tests in the Red April 26, 2007 - original post\nAs your test suite grows, you will find yourself needing to refactor your tests. However, your tests don\u0026rsquo;t have tests!\nOne thing you can do is intentionally break the test, refactor the test, and make sure the test still fails as expected.\nJust remember to revert your code under test!\n"
}]
[
{
	"uri": "http://example.org/tour-of-c++/01_the_basics/",
	"title": "The Basics",
	"tags": [],
	"description": "",
	"content": " Don\u0026rsquo;t panic! All will become clear in time. Don\u0026rsquo;t use the built-in features exclusively or on their own. On the contrary, built-in features are usually best used indirectly through libraries, such as the ISO C++ standard library.\nclass Date { // ... public: Month month() const; // good int month() cont; // bad // ... }; void change_speed(double s); // bad void change_speed(Speed s); // good // ... change_speed(2.3); // bad change_speed(32m / 10s); // good  You don\u0026rsquo;t have to know every detail of C++ to write good programs.\n Focus on programming techniques, not on language features.\n For the final word on language definition issues, see the ISO C++ standard.\n \u0026ldquo;Package\u0026rdquo; meaningful operations as carefully named functions.\n// bad void read_and_print(istream\u0026amp; is) { int x; if (is \u0026gt;\u0026gt; x) cout \u0026lt;\u0026lt; \u0026quot;the int is \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; '\\n'; else cerr \u0026lt;\u0026lt; \u0026quot;no int on input\\n\u0026quot;; } // good auto lessT = [](T x, T y) { return x.rank() \u0026lt; y.rank() \u0026amp;\u0026amp; x.value() \u0026lt; y.value(); }; sort(a, b, lessT); find_if(a, b, lessT);  A function should perform as single logical operation.\n// bad void read_and_print() { int x; cin \u0026gt;\u0026gt; x; // check for errors cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } // better auto read = [](auto\u0026amp; input, auto\u0026amp; value) { input \u0026gt;\u0026gt; value; // check for errors }; auto print(auto\u0026amp; output, const auto\u0026amp; value) { output \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }  Keep functions short.\n// bad: complex control structure double simple_func(double val, int flag1, int flag2) // simple_func: takes a value and calculates the expected ASIC output, // given the two mode flags. { double intermediate; if (flag1 \u0026gt; 0) { intermediate = func1(val); if (flag2 % 2) intermediate = sqrt(intermediate); } else if (flag1 == -1) { intermediate = func1(-val); if (flag2 % 2) intermediate = sqrt(-intermediate); flag1 = -flag1; } if (abs(flag2) \u0026gt; 10) { intermediate = func2(intermediate); } switch (flag2 / 10) { case 1: if (flag1 == -1) return finalize(intermediate, 1.171); break; case 2: return finalize(intermediate, 13.1); default: break; } return finalize(intermediate, 0.); } // better: refactor double func1_muon(double val, int flag) { // ??? } double func1_tau(double val, int flag1, int flag2) { // ??? } double simple_func(double val, int flag1, int flag2) // simple_func: takes a value and calculates the expected ASIC output, // given the two mode flags. { if (flag1 \u0026gt; 0) return func1_muon(val, flag2); if (flag1 == -1) // handled by func1_tau: flag1 = -flag1; return func1_tau(-val, flag1, flag2); return 0.; }  Use overloading when functions perform conceptually the same task on different types.\n If a function may have to be evaluated at compile time, declare it constexpr.\nconstexpr int fac(int n) { constexpr int max_exp = 17; // constexpr enables max_exp to be used in Expects Expects(0 \u0026lt;= n \u0026amp;\u0026amp; n \u0026lt; max_exp); // prevent silliness and overflow int x = 1; for (int i = 2; i \u0026lt;= n; ++i) x *= i; return x; }  Understand how language primitives map to hardware.\n Use digit separators to make large literals readable.\nauto c = 299'792'458; auto hello = \u0026quot;Hello!\u0026quot;s; auto interval = 100ms; // \u0026lt;chrono\u0026gt;  Avoid complicated expressions.\n// bad: multiple assignments \u0026quot;hidden\u0026quot; in subexpressions x = a + (b = f()) + (c = g()) * 7; // bad: relies on commonly misunderstood precedence rules x = a \u0026amp; b + c * d \u0026amp;\u0026amp; e ^ f == 7; // bad: undefined behavior x = x++ + x++ + ++x; x = k * y + z; // OK auto t1 = k * y; // bad: unnecessarily verbose x = t1 + z; if (0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; max) // OK auto t1 = 0 \u0026lt;= x; // bad: unnecessarily verbose auto t2 = x \u0026lt; max; if (t1 \u0026amp;\u0026amp; t2) // ...  Avoid narrowing conversions.\ndouble d = 7.9; int i = d; // bad: narrowing: i becomes 7 i = (int) d; // bad: we're going to claim this is still not explicit enough // ... // using guideline support library i = narrow_cast\u0026lt;int\u0026gt;(d); // ok (you asked for it): narrowing: i becomes 7 i = narrow\u0026lt;int\u0026gt;(d); // ok: throws narrowing_error  Minimize the scope of a variable.\n Avoid \u0026ldquo;magic constants\u0026rdquo;; use symbolic constants.\n// bad: magic constant 12 for (int m = 1; m \u0026lt;= 12; ++m) cout \u0026lt;\u0026lt; month[m] \u0026lt;\u0026lt; '\\n'; // better constexpr int first_month = 1; constexpr int last_month = 12; for (int m = first_month; m \u0026lt;= last_month; ++m) cout \u0026lt;\u0026lt; month[m] \u0026lt;\u0026lt; '\\n'; // better still for (auto m : month) cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; '\\n';  Prefer immutable data.\n Declare one name (only) per declaration.\nchar *p, c, a[7], *pp[7], **aa[10]; // yuck!  Structured bindings are specifically designed to introduce several variables.\nauto [iter, inserted] = m.insert_or_assign(k, val); if (inserted) { /* new entry was inserted */ }  Keep common and local names short, and keep uncommon an non-local names longer.\ntemplate\u0026lt;typename T\u0026gt; // good void print(ostream\u0026amp; os, const vector\u0026lt;T\u0026gt;\u0026amp; v) { /* ... */ } template\u0026lt;typename Element_type\u0026gt; // bad: verbose, hard to read void print(ostream\u0026amp; target_stream, const vector\u0026lt;Element_type\u0026gt;\u0026amp; current_vector) { /* ... */ } void use1(const string\u0026amp; s) { // ... tt(s); // bad: what is tt()? // ... } void use1(const string\u0026amp; s) { // ... trim_tail(s); // better // ... } // bad: large functions are de facto non-local; vr, vi and out need to be more meaningful void complicated_algorithm(vector\u0026lt;Record\u0026gt;\u0026amp; vr, const vector\u0026lt;int\u0026gt;\u0026amp; vi, map\u0026lt;string, int\u0026gt;\u0026amp; out) { // ... 500 lines of code using vr, vi, and out ... }  Avoid similar-looking names.\nif (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise(); // bad struct foo { int n; }; struct foo foo(); // bad: foo is a type already in scope struct foo x = foo(); // bad: requires disambiguation  Avoid ALL_CAPS names. ALL_CAPS should used for macros only.\n Prefer the {}-initializer syntax for declarations with a named type.\nint x {7.9}; // error: narrowing int y = 7.9; // y becomes 7. Hope for a compiler warning  Use auto to avoid repeating type names.\nauto p = v.begin(); // vector\u0026lt;int\u0026gt;::iterator auto h = t.future(); auto q = make_unique\u0026lt;int[]\u0026gt;(s); auto f = [](int x){ return x + 10; };  Avoid auto for initializer lists.\nauto lst = { 1, 2, 3 }; // lst is an initializer list auto x{1}; // x is an int (in C++17; initializer_list in C++11)  Avoid uninitialized variables.\nvoid use(int arg) { int i; // bad: uninitialized variable // ... i = 7; // initialize i } void use(int arg) // ok { int i = 7; // ok: initialized string s; // ok: default initialized // ... }  Keep scopes small.\nint i; // bad: i is needlessly accessible after loop for (i = 0; i \u0026lt; 20; ++i) { /* ... */ } for (int i = 0; i \u0026lt; 20; ++i) { /* ... */ } // good: i is local to for-loop // bad string fn = name + \u0026quot;.txt\u0026quot;; ifstream is {fn}; // ... 200 lines of code without intended use of fn or is ...  When declaring a variable in the condition of an if-statement, prefer the version with the implicit test against 0.\n Use unsigned for bit manipulation only.\nunsigned area(unsigned height, unsigned width) { return height*width; } // ... int height; cin \u0026gt;\u0026gt; height; auto a = area(height, 2); // if the input is -2 a becomes 4294967292  Keep use of pointers simple and straightforward.\nvoid f(int* p, int count) { if (count \u0026lt; 2) return; int* q = p + 1; // bad: pointer arithmetic ptrdiff_t d; int n; d = (p - \u0026amp;n); // ok d = (q - p); // ok int n = *p++; // bad: pointer arithmetic if (count \u0026lt; 6) return; p[4] = 1; // bad: pointer indexing p[count - 1] = 2; // bad: pointer indexing use(\u0026amp;p[0], 3); // bad: implicit conversion of array to pointer }  Use nullptr rather than 0 or NULL.\n Don\u0026rsquo;t declare a variable until you have a value to initialize with.\nstring s; // ... no use of s here ... s = \u0026quot;what a waste\u0026quot;;  Dont\u0026rsquo; say in comments what can be clearly stated in code.\n// bad auto x = m * v1 + vv; // multiply m with v1 and add the result to v  State intent in comments.\n// sort c in the order determined by \u0026lt;, keep equal elements (as defined by ==) in // their original relative order void stable_sort(Sortable\u0026amp; c) { // ... quite a few lines of non-trivial code ... }  Maintain a consistent indentation style.\n  "
},
{
	"uri": "http://example.org/tour-of-c++/02_user-defined-types/",
	"title": "User-Defined Types",
	"tags": [],
	"description": "",
	"content": " Prefer well-defined user-defined types over built-in types when the built-in types are too low level. Organize related data into structures Represent the distinction between an interface and an implementation using a class A struct is simply a class with its members `public by default Define constructors to guarantee and simplify initialization of classes Avoid \u0026ldquo;naked\u0026rdquo; unions; wrap them in a class together with a type field Use enumerations to represent sets of named constants Prefer class enums over \u0026ldquo;plain\u0026rdquo; enums to minimize surprises Define operations on enumerations for safe and simple use  "
},
{
	"uri": "http://example.org/tour-of-c++/",
	"title": "Tour of C++",
	"tags": [],
	"description": "",
	"content": " Bjarne Stroustrup Tour of C++ Second Edition\n"
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/",
	"title": "Notebook",
	"tags": [],
	"description": "",
	"content": " Notebook Welcome! You have stumbled upon Andrew Guerrero\u0026rsquo;s notebook. If you are looking for some notes on software development and software engineering, then you have come to the right place.\n"
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
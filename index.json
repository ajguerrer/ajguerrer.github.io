[
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/",
	"title": "Google Testing Blog",
	"tags": [],
	"description": "",
	"content": "Google Google Testing Blog Notes taken from Google Testing Blog with examples in C++ and the Google Test framework.\n "
},
{
	"uri": "https://ajguerrer.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/general/",
	"title": "General Notes",
	"tags": [],
	"description": "",
	"content": "Test Reliability  Smaller tests run faster, are less flakey, and isolate failures. As a general rule of thumb, favor a composition of 70% small, 20% medium, and 10% large tests.1 Test binary size and memory usage, including third-party testing tools, have a strong correlation on whether a test is flaky.2 Beware of using UI testing to verify underlying functionality. In these cases, it is cheaper and more reliable to have smaller tests that break closer to the source of the problem.3 4 Hermetic servers add speed and reliability into end-to-end tests. A environment is considered Hermetic if it can run an entire system under test on a single machine with fake network connections and database implementations.5 Filter out flakey tests by rerunning failing tests. If a test fails three times in a row, consider it a real failure.6 Build testability into the product. For example, a real-time system can rely on a fake clock instead of a hardware clock. Processes can spawn other processes attached to a debugger with debugging flags.7  Code Quality  Releasing often gives teams an incentive to automate testing and reduce coupling with the rest of the system.8 When a team provides fakes and writes tests for them, they become clients of their own software. Experiencing the perspective of the client gives the team an incentive to make their API easier to use.8 While writing the header first encourages consideration for the interface, writing tests first encourages consideration for how the interface will be used.9 Good code quality is taught, not enforced. Create a culture that teaches code quality through code review, pair programming, and mentoring.7  Productivity  Automation is costly. Automate only the tests that you find yourself running often to reliably catch regressions on features with business value.3 Speed up the feedback loop between test engineers and development engineers. Share the same space, tools, daily stand-ups, and design discussions.3 Effective automation depends on test design. Good test design is built from a solid foundation of manual tests.10 If a test plan isn't worth bothering to update, it isn't worth creating in the first place. A quick brainstorming session will suffice.11 Use formatting tools, like clang-format, to improve readability.12  Infrastructure  Remove the detective work of tracking down bad changes by investing in a pre-submit system that runs automated tests against the commit before it reaches the depot.13 6 Don't fall behind on updating third party dependencies. Update them quickly by setting up CI system with dependencies pinned at head.14 Avoid making more than one branch by putting risky new changes behind feature flags.12 Constantly look for opportunities to make the build system faster. Reduce the amount of code being compiled, replace tools with faster counterparts, and use distributed build systems.15 Release early and release often. Services and websites can deploy rapidly. A good target for client projects is Chromes six week cycle.15  Metrics \u0026amp; Logging  Pre- vs post-production defect ratio and a breakdown of defects by component or functional area help identify holes in test.16 Premature performance optimization makes bad code. Develop in a clean, maintainable and extensible manner first, and then let benchmarks drive performance optimizations.17 Remove unwanted noise by logging with conditional verbosity. Log all levels to a logging queue. If a transaction completes successfully, discard the unimportant levels.18 Use two sets of logging levels, one for production builds and one for development builds.18 Trace the time spent on every significant processing step. Measuring is the only way to detect performance issues or make claims about performance.18 Write automated performance tests for performance sensitive parts of your product.15    https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-from.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2007/10/automating-tests-vs-test-automation.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2008/06/taming-beast-aka-how-to-test-ajax.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2012/10/hermetic-servers.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/10/hackable-projects-pillar-2-debuggability.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2017/02/discomfort-as-tool-for-change.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2008/09/test-first-is-fun_08.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2008/09/presubmit-and-performance.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/09/10-minute-test-plan.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/08/hackable-projects.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/06/burning-test-questions-at-google.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2015/05/multi-repository-development.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2016/11/hackable-projects-pillar-3.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2007/10/post-release-closing-loop_02.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2007/10/performance-testing.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2013/06/optimal-logging.html \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/testable_code/",
	"title": "Guide to Writing Testable Code",
	"tags": [],
	"description": "",
	"content": "Miško Hevery  You may find Miško's original guide here.\nDependency Injection A testable class is one that can be constructed in isolation or with test double collaborators. Once constructed, they have all the dependencies they need. This is known as Dependency Injection.\nDependencies do not need to be concrete classes. Abstract classes allow testers to leverage inheritance for creating test double collaborators. This is the primary tool in a testers toolkit and the primary benefit Dependency Injection brings.\nFixing violations Below are some examples of constructor flaws and how they can be fixed with Dependency Injection.\nStatic method calls class AccountView { public: AccountView() { user_ = RPCClient::GetInstance().GetUser(); } private: User user_; } TEST(AccountViewTest, SlowAndFlakyTest) { // Unit test is slow and requires working network connection.  AccountView view; };  class AccountView { public: explicit AccountView(const User\u0026amp; user): user_(user) {} private: User user_; }; TEST(AccountViewTest, FastAndReliableTest) { // User does not need to be retrieved over the network.  MockUser user; AccountView view(user); }  Conditional logic class Car { public: explicit Car(CarType type) { switch (type) { case kCoupe: { engine_ = FastEngine(); tires_ = SmoothTires(); break; } case kTruck: { engine_ = StrongEngine(); tires_ = KnobbyTires(); } default: assert(false); } } private: Engine engine_; Tires tires_; }; TEST(CarTest, HardToTest) { // Want a car with fake engine and tires but can only make real ones.  Car car(kCoupe); }  class Car { public: Car(std::unique_ptr\u0026lt;Engine\u0026gt; engine, std::unique_ptr\u0026lt;Tires\u0026gt; tires) : engine_(std::move(engine)), tires_(std::move(tires)) {} private: std::unique_ptr\u0026lt;Engine\u0026gt; engine_; std::unique_ptr\u0026lt;Tires\u0026gt; tires_; }; TEST(CarTest, EasyToTest) { // Car is fully configurable  Car car(std::make_unique\u0026lt;FakeEngine\u0026gt;(), std::make_unique\u0026lt;FakeTires\u0026gt;()); }  Constructing dependencies  class House { public: House() : kitchen_(), bedroom_() {} // ...  private: Kitchen kitchen_; Bedroom bedroom_; }; TEST(HouseTest, HardToTest) { // house is stuck with Kitchen and Bedroom objects  House house; }  class House { public: House(std::unique_ptr\u0026lt;Kitchen\u0026gt; kitchen, std::unique_ptr\u0026lt;Bedroom\u0026gt; bedroom) : kitchen_(std::move(kitchen)), bedroom_(std::move(bedroom)) {} // ...  private: std::unique_ptr\u0026lt;Kitchen\u0026gt; kitchen_; std::unique_ptr\u0026lt;Bedroom\u0026gt; bedroom_; }; TEST(HouseTest, EasyToTest) { // house uses lightweight test doubles  House house(std::make_unique\u0026lt;MockKitchen\u0026gt;(), std::make_unique\u0026lt;MockBedroom\u0026gt;()); }  Partial construction  class VisualVoicemail { public: // Constructs a partially initialized VisualVoicemail.  // Don\u0026#39;t forget to call Initialize in production, or SetCalls in test!  explicit VisualVoicemail(const User\u0026amp; user) : user_(user) {} void Initialize() { calls_ = Server::GetCallsFor(user_); } private: // Hack to allow test access to private methods.  // Making this function public is not a better idea.  friend class VisualVoicemailTest_BrittleDesign_Test; void SetCalls(std::vector\u0026lt;Call\u0026gt;\u0026amp; calls) { calls_ = calls; } User user_; std::vector\u0026lt;Call\u0026gt; calls_; }; TEST(VisualVoicemailTest, BrittleTest) { DummyUser user; VisualVoicemail voicemail(user); std::vector\u0026lt;Call\u0026gt; calls = BuildListOfTestCalls(); voicemail.SetCalls(calls); }  class VisualVoicemail { public: explicit VisualVoicemail(const std::vector\u0026lt;Call\u0026gt;\u0026amp; calls) : calls_(calls) {} private: std::vector\u0026lt;Call\u0026gt; calls_; }; TEST(VisualVoicemailTest, FlexibleTest) { VisualVoicemail voicemail(BuildListOfTestCalls()); }  Law of Demeter A class becomes difficult to test if it gets its dependencies from anywhere besides it's interface. For example, a class may get a dependency by asking one of it dependencies, breaking the Law of Demeter.\nViolations of the Law of Demeter are a sign of bad Dependency Injection, for passing in the wrong dependency, and bad encapsulation, for exposing secondary dependencies in the first place.\nFixing violations Below are examples of Law of Demeter violations and how they can be fixed with accurate interfaces and encapsulation.\nIndirect dependencies class SalesTaxCalculator { public: SalesTaxCalculator(const TaxTable\u0026amp; taxTable) : taxTable_(taxTable) {} float ComputeSalesTax(const User\u0026amp; user, const Invoice\u0026amp; invoice) { // Get the correct dependencies first.  Address address = user.GetAddress(); float amount = invoice.GetSubTotal(); // Then, do the calculation.  return amount * taxTable_.GetTaxRate(address); } public: TaxTable taxTable_; } TEST(SalesTaxCalculatorTest, ComplexTest) { SalesTaxCalculator calc(TaxTable()); User user(Address(\u0026#34;1600 Amphitheater Parkway...\u0026#34;)); Invoice invoice(1, ProductX(95.00)); // ...  EXPECT_EQ(0.09, calc.ComputeSalesTax(user, invoice)); }  class SalesTaxCalculator { public: SalesTaxCalculator(const TaxTable\u0026amp; taxTable) : taxTable_(taxTable) {} float ComputeSalesTax(const Address\u0026amp; address, const float amount) { // Already have the correct dependencies; do the calculation.  return amount * taxTable_.GetTaxRate(address); } public: TaxTable taxTable_; } TEST(SalesTaxCalculatorTest, StraightforwardTest) { SalesTaxCalculator calc(TaxTable()); Address address(\u0026#34;1600 Amphitheater Parkway...\u0026#34;) // ...  EXPECT_EQ(0.09, calc.ComputeSalesTax(address, 95.00)); }  Overusing member access operator class LoginPage { public: LoginPage(std::shared_ptr\u0026lt;RPCClient\u0026gt; client, const HttpRequest\u0026amp; request) : client_(client), request_(request) {} bool Login() { // Even using member access access operator once is one more time than it  // needs to be.  std::string cookie = request_.GetCookie(\u0026#34;g\u0026#34;); // Using a member access operator twice in one statement is right out!  return client_.GetAuthenticator().Authenticate(); } private: std::shared_ptr\u0026lt;RPCClient\u0026gt; client_; HttpRequest request_; }; TEST(LoginPageTest, ComplexBrittleTest) { MockRPCClient mock_client(make_shared\u0026lt;FakeAuthenticator\u0026gt;()); std::vector\u0026lt;Cookie\u0026gt; cookies = {Cookie(\u0026#34;g\u0026#34;, \u0026#34;xyz123\u0026#34;)}; MockHttpRequest mock_request(cookies); LoginPage page(client, request); EXPECT_CALL(mock_client, GetAuthenticator()); EXPECT_CALL(mock_request, GetCookie(\u0026#34;g\u0026#34;)); EXPECT_TRUE(page.Login()); }  class LoginPage { public: LoginPage(std::shared_ptr\u0026lt;Authenticator\u0026gt; authenticator, const Cookie\u0026amp; cookie) : authenticator_(authenticator), cookie_(cookie) {} bool Login() { return authenticator_.Authenticate(cookie_); } private: std::shared_ptr\u0026lt;Authenticator\u0026gt; authenticator_; Cookie cookie_; }; TEST(LoginPageTest, SimpleFlexibleTest) { LoginPage page(std::make_shared\u0026lt;FakeAuthenticator\u0026gt;(), Cookie(\u0026#34;g\u0026#34;, \u0026#34;xyz123\u0026#34;)); EXPECT_TRUE(page.Login()); }  Exposing dependencies class UpdateBug { public: explicit UpdateBug(std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db) : db_(db) {} void Execute(const Bug\u0026amp; bug) { // Impose internal lock management on client.  db_-\u0026gt;GetLock().Lock(); db_-\u0026gt;Save(bug); db_-\u0026gt;GetLock().Unlock(); } private: std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db_; }; // This test shouldn\u0026#39;t be needed, but we must enforce Lock/Unlock is called // around Save. TEST(UpdateBugTest, HardToTest) { MockLock mock_lock; auto mock_db = std::make_shared\u0026lt;MockDatabase\u0026gt;(); Bug bug(\u0026#34;description\u0026#34;); UpdateBug updateBug(mock_db); EXPECT_CALL(*mock_db, GetLock()).WillRepeatedly(ReturnRef(mock_lock)); { InSequence dummy; EXPECT_CALL(mock_lock, Lock()); EXPECT_CALL(*mock_db, Save(Ref(bug))); EXPECT_CALL(mock_lock, Unlock()); } updateBug.Execute(bug); }  class UpdateBug { public: explicit UpdateBug(std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db) : db_(db) {} void Execute(const Bug\u0026amp; bug) { // Save calls Lock/Unlock internally  db_-\u0026gt;Save(bug); } private: std::shared_ptr\u0026lt;DatabaseInterface\u0026gt; db_; }; // Go strait to testing state. No need for mock test since locking interaction // is encapsulated in the database. TEST(UpdateBugTest, EasyTest) { auto db = std::make_shared\u0026lt;FakeDatabase\u0026gt;(); UpdateBug updateBug(); Bug bug(\u0026#34;description\u0026#34;); updateBug.Execute(bug); EXPECT_EQ(bug, db.GetLastSaved()); }  Context Objects class MembershipPlan { // ...  public: void ProcessOrder(UserContext\u0026amp; userContext) { User user = userContext.GetUser(); PlanLevel level = userContext.GetLevel(); Order order = userContext.GetOrder(); // process...  } }; TEST(MembershipPlanTest, BrittleUnreadableTest) { MembershipPlan plan; UserContext userContext; userContext.SetUser(User(\u0026#34;Kim\u0026#34;)); userContext.SetLevel(PlanLevel(143, \u0026#34;yearly\u0026#34;)); userContext.SetOrder(Order(\u0026#34;SuperDeluxe\u0026#34;, 100, true)); // Hopefully this is all the setup the userContext needs to call ProcessOrder  plan.ProcessOrder(userContext); // Make assertions against userContext and plan... }  class MembershipPlan { // ...  public: void ProcessOrder(User\u0026amp; user, Order\u0026amp; order, const PlanLevel\u0026amp; level) { // process...  } }; TEST(MembershipPlanTest, FlexibleSimpleTest) { MembershipPlan plan; User user(\u0026#34;Kim\u0026#34;); Order order(\u0026#34;SuperDeluxe\u0026#34;, 100, true); const PlanLevel level(143, \u0026#34;yearly\u0026#34;); plan.ProcessOrder(user, order, level); // Make assertions against user, order and plan... }  Global State Global state is difficult to understand. Ideally, the interface of an object should fully describe it's dependencies. Global state ruins this ideal because it can be used anywhere without warning. Such flexibility may seem convenient to the original developer, but to others it's confusing. Especially in large code bases, it can be difficult to realize that some global state exists and reason about the circumstances in which it should or shouldn't be used.\nGlobal state is the enemy of testing. It strongly couples itself to the code that uses it. Global scope encourages widespread usage, further compounding coupling issues. Coupling to concrete types makes it impossible to write test doubles and global state must be concrete because it uses the static keyword.\nFixing violations Below are some examples of global state and how they can be fixed with Dependency Injection. However, Dependency Injection alone is often not enough to fix static methods. For those, an adapter called the repository pattern can help remove the static cling.\nNote, the solutions to the examples should not feel good and require a lot of work. It is really tough to test global state. The best solution is to never use it or refactor away from it altogether.\nSingletons class LoginService { public: static LoginService\u0026amp; GetInstance() { static LoginService instance; return instance; } // ... }; class AdminDashboard { public: bool IsAuthenticatedAdmin(const User\u0026amp; user) { return LoginService::GetInstance().IsAuthenticatedAdmin(user); } // ... }; TEST_F(AdminDashboardTest, FlakeySlowAndBrittleTest) { // Forced to use the real LoginService singleton.  User user(\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;); ASSERT_TRUE(adminDashboard_.IsAuthenticatedAdmin(user)); }  class LoginServiceRepository { public: virtual ~LoginServiceRepository() = default; virtual LoginService\u0026amp; GetInstance() = 0; }; class AdminDashboard { public: explicit AdminDashboard(std::shared_ptr\u0026lt;LoginServiceRepository\u0026gt; loginService) : loginService_(loginService) {} bool IsAuthenticatedAdmin(const User\u0026amp; user) { return loginService_-\u0026gt;GetInstance().IsAuthenticatedAdmin(user); } private: std::shared_ptr\u0026lt;LoginServiceRepository\u0026gt; loginService_; }; TEST(AdminDashboardTest, ReliableFastAndFlexibleTest) { // Can now use test doubles for the LoginService singleton.  AdminDashboard adminDashboard(std::make_shared\u0026lt;MockLoginService\u0026gt;()); User user(\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;); ASSERT_TRUE(adminDashboard.IsAuthenticatedAdmin(user)); }  Flags static bool kFlagUseRealBackend; class RpcClient { public: static RpcClient\u0026amp; GetInstance() { static RpcClient instance; return instance; } bool IsReal() { return backend_-\u0026gt;IsReal(); } private: RpcClient() { if (kFlagUseRealBackend) { backend_ = std::make_unique\u0026lt;RealBackend\u0026gt;(); } else { backend_ = std::make_unique\u0026lt;DummyBackend\u0026gt;(); } } //...  std::unique_ptr\u0026lt;Backend\u0026gt; backend_; }; // The 2nd test to run will fail if both tests are run together // because the RpcClient is static.  TEST(RpcClientTest, SmallComplexAndFlakeyTest) { kFlagUseRealBackend = false; RpcClient\u0026amp; client = RpcClient::GetInstance(); EXPECT_FALSE(client.IsReal()); } TEST(RpcClientTest, LargeComplexAndFlakeyTest) { kFlagUseRealBackend = true; RpcClient\u0026amp; client = RpcClient::GetInstance(); EXPECT_TRUE(client.IsReal()); }  class RpcClient { public: explicit RpcClient(std::unique_ptr\u0026lt;Backend\u0026gt; backend) : backend_(std::move(backend)) {} bool IsReal() { return backend_-\u0026gt;IsReal(); } private: std::unique_ptr\u0026lt;Backend\u0026gt; backend_; }; // Now, both tests pass.  TEST(RpcClientTest, SmallSimpleAndReliableTest) { RpcClient client(std::make_unique\u0026lt;DummyBackend\u0026gt;()); EXPECT_FALSE(client.IsReal()); } TEST(RpcClientTest, LargeSimpleAndReliableTest) { RpcClient client(std::make_unique\u0026lt;RealBackend\u0026gt;()); EXPECT_TRUE(client.IsReal()); }  Static methods class TrainSchedule { // ...  std::shared_ptr\u0026lt;Schedule\u0026gt; FindNextTrain() { // ...  // Slow third party service  if (TrackStatus::IsClosed(track)) { // ...  } // ...  return schedule; } } TEST_F(TrainScheduleTest, FlakeySlowAndBrittleTest) { // Forces third party TrackStatus to get called  ASSERT_NE(trainSchedule_.FindNextTrain(), nullptr); }  class TrackStatusRepository { public: virtual ~TrackStatusRepository() = default; virtual bool IsClosed(const Track\u0026amp; track) = 0; }; class RealTrackStatusRepository : public TrackStatusRepository { public: // ... Wrap each of the third party library\u0026#39;s methods.  bool IsClosed(const Track\u0026amp; track) { return TrackStatus::IsClosed(track); } }; class TrainSchedule { public: TrainSchedule(std::unique_ptr\u0026lt;TrackStatusRepository\u0026gt; trackStatus) : trackStatus_(std::move(trackStatus)) {} // ...  std::shared_ptr\u0026lt;Schedule\u0026gt; FindNextTrain() { // ...  if (trackStatus_-\u0026gt;IsClosed(track)) { // ...  } // ...  return schedule; } private: std::unique_ptr\u0026lt;TrackStatusRepository\u0026gt; trackStatus_; }; TEST(TrainScheduleTest, ReliableFastAndFlexibleTest) { // Now TrainSchedule can be tested in isolation.  TrainSchedule trainSchedule(std::make_unique\u0026lt;StubTrackStatusRepository\u0026gt;()); ASSERT_NE(trainSchedule.FindNextTrain(), nullptr); }  Single Responsibility Principle If you have a class that feels like it:\n Contains hidden interactions that make you scratch your head. Is difficult to read and retain in memory. Is difficult to reason about its state or contains a bunch of conditional logic. Is difficult to describe what it does or the word \u0026lsquo;and\u0026rsquo; is used. Requires too many dependencies. Requires too much work to write a test double. Requires too many tests for full coverage. Requires large tests with complex setup/teardown.  Then, that class is likely violating the Single Responsibility Principle. Such classes hide points of flexibility and encapsulate interaction instead of encapsulating behavior. Poor flexibility and encapsulation creates brittle design and strong coupling. The result is a class that's hard to test.\nFixing violations Opportunity to fix a violation of the Single Responsibility Principle is either proactive or reactive, depending on whether the violation is caught before or after it's committed to the codebase.\nIt should go without saying that the proactive approach is less work.\nProactive  Identify the individual responsibilities. Give each responsibility a crisp name. Extract functionality into each class. Celebrate how much easier the class is to test.  Reactive  Extract a class in the place where behavior is being altered with new functionality. Start to move chunks of behavior out of the legacy class and test each chunk in isolation.  static methods are a sign of a homeless method. It likely belongs to one of the parameters it takes.\n "
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/whittaker/",
	"title": "James Whittaker",
	"tags": [],
	"description": "",
	"content": "The Seven Plagues of Software Testing  Aimlessness - Do not test for the sake of testing. Every test should have a goal. Document what works and analyze what doesn't. Then, share with your colleagues.1 Repetitiveness - Running the same test suite over again without finding new bugs does not mean that there are no bugs. Variation is healthy.2 Amnesia - Chances are the problem your are trying to solve has been solved before. If the same issue keeps stinging you, or you had to answer a question the hard way, document it and put it in a place others will find it.3 Boredom - A bored tester rushes through the tactical aspects of testing without considering the interesting strategic aspects. The day testing gets \u0026ldquo;figured out\u0026rdquo; is the day it gets completely automated away.4 Homelessness - Testers are homeless. They don't actually live in the software like users do. Some bugs are only found with the hands of users doing their work in their environment.5 Blindness - Testers require tools to provide helpful feedback from software. It's tempting to settle down with a trusty set of tools, but doing so causes self-inflicted blindness to a growing ecosystem of useful feedback.6 Entropy - Testers increase entropy by giving developers things to do. This is unavoidable, but preventative. As developers do more during development, testers add less work, and entropy tends towards a minimum.7  An Ingredients List for Testing  Product expertise - A good developer knows how the product works; a good tester knows how to use it.8 Bill of materials - Testers should bea able to reference a complete list of features that can be tested.9 Risk analysis - Features are not equally important, or equally time consuming to test. Have a model to quantitatively analyze the risk of each feature.10 Domain expertise - It is not enough to be good at testing. Testers also need expertise with the technologies of the domain the product operates in.11 Test guidance - Whether it be technique, nomenclature, or history, testers need a way to identify and store tribal knowledge of the team.12 Variation - Tests often get stale. Wasting time running stale tests is also a form of risk. Adding variation can breathe new life into stale tests.13 Completeness analysis - Teams need a model to measure how well their testing efforts have covered the risk landscape of their product.14  How Google Tests Software Engineers are loaned out to product teams on an as-needed basis. Engineers are free to change product teams at their own cadence.15\nDevelopers own quality while testers support developers with tools and feedback. As developers get better at testing, less testers are needed. Successful teams have higher developer-to-tester ratios. 15\nDevelopment and test are not treated as separate disciplines. Developers test and testers code.16 Instead, each of the three roles look at the product from different angles:\n SWE (Software Engineer) - Feature creators responsible for their work. SWEs design and write features, and then prove they work by writing and running tests. SET (Software Engineer in Test) - Codebase caretakers who enable SWEs to write tests. SETs refactor code for testability, and write test features including test doubles and test framework. TE (Test Engineer) - Product experts who analyze quality and risk from the perspective of the user. TEs write large tests and automation scrips as well as drive test execution and interpret their results.17  SETs and TEs\u0026rsquo; are usually not involved early in the design phase of a product. Only when the product gains traction do they begin to exert their influence.18 19\nSETs and SWEs have similar skill sets. Conversions from one role to another are common.20\nQuality is a work in progress that relies on getting product out to users and receiving feedback as quickly as possible. As its being developed, a release is pushed through several channels in order of increasing confidence in quality:\n Canary - Only fit for ultra tolerant users running experiments. Dev - Used by developers for day-to-day work. Test - Used internally for day-to-day work. Beta/Release - Fit for external exposure.10  Tests are classified by scope, falling under three categories:\n Small - Covers a single function, focusing on logic. Medium - Covers a function and its nearest neighbors, focusing on interoperability. Large - Covers an entire user scenario, focusing on business requirements.21  If a test doesn't require human cleverness or intuition, it is automated. Bug reporting is automated too.21\n  https://testing.googleblog.com/2009/06/7-plagues-of-software-testing.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/06/by-james.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-amnesia.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-boredom.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-homelessness.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/07/plague-of-blindness.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2009/09/plague-of-entropy.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/08/ingredients-list-for-testing-part-one.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/08/ingredients-list-for-testing-part-two.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/03/how-google-tests-software-part-four.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/09/ingredients-list-for-testing-part-four.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/10/ingredients-list-for-testing-part-five.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/11/ingredients-list-for-testing-part-six.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2010/11/ingredients-list-for-testing-part-seven.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/01/how-google-tests-software.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/02/how-google-tests-software-part-three.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/02/how-google-tests-software-part-two.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/05/how-google-tests-software-part-six.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/05/how-google-tests-software-part-seven.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/05/how-google-tests-software-break-for-q.html \u0026#x21a9;\u0026#xfe0e;\n https://testing.googleblog.com/2011/03/how-google-tests-software-part-five.html \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://ajguerrer.github.io/",
	"title": "Notebook",
	"tags": [],
	"description": "",
	"content": "Andrew Guerrero Notebook Welcome! You have stumbled upon Andrew Guerrero's notebook.\nIf you are looking for notes on software development and engineering, then you have come to the right place.\n "
},
{
	"uri": "https://ajguerrer.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/tott/",
	"title": "Testing on the Toilet",
	"tags": [],
	"description": "",
	"content": "This page contains potable bits of testing best-practices that will keep you riveted to your seat.\nTests Too DRY? Make Them DAMP! December 03, 2019 - original post\nThough the DRY (\u0026ldquo;Don't Repeat Yourself\u0026rdquo;) principle is great for production code, tests don't test themselves.\nclass ForumTest : public ::testing::Test { protected: void SetUp() override { for (auto user : users_) { forum_.Register(user); } } Forum forum_; std::vector\u0026lt;User\u0026gt; users_ = {User(\u0026#34;Alice\u0026#34;), User(\u0026#34;Bob\u0026#34;)}; } TEST_F(ForumTest, CanRegisterMultipleUsers) { for (auto user : users_) { EXPECT_TRUE(forum_.HasRegisteredUser(user)); } }  Tests should optimize for readability, even at the expense of redundancy. Prefer the DAMP (\u0026ldquo;Descriptive and Meaningful Phrases\u0026rdquo;) principle.\nTEST(ForumTest, CanRegisterMultipleUsers) { Forum forum; User user1(\u0026#34;Alice\u0026#34;); User user2(\u0026#34;Bob\u0026#34;); forum.Register(user1); forum.Register(user2); EXPECT_TRUE(forum.HasRegisteredUser(user1)); EXPECT_TRUE(forum.HasRegisteredUser(user2)); }  Exercise Service Call Contracts in Tests November 27, 2018 - original post\nIf the code under test relies on the contract of a service, prefer exercising the service call instead of mocking it out. Some service owners provide a fake. Otherwise, use a hermetic server.\nMake Interfaces Hard to Misuse July 25, 2018 - original post\nDon't push the responsibility of maintaining invariants on the caller.\nclass Vector { explicit Vector(int num_slots); int RemainingSlots() const; void AddSlots(int num_slots); void Insert(int value); };  In the code above, the caller needs to check RemainingSlots, and if 0, AddSlots in order for Insert to work properly.\nInstead, Insert could automatically manage slots.\nclass Vector { explicit Vector(int num_slots); void Insert(int value); };  Other signs an interface is hard to use:\n Initialize / Deitialize functions. Allowing partially created objects. Parameters that can have invalid values.  Sometimes it's not practical to have a foolproof interface. In those cases rely on static analysis or documentation.\nOnly Verify Relevant Method Arguments June 26, 2018 - original post\nTests become fragile when they expect exact values on irrelevant arguments.\nTEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fake_clock_.SetTime(kNewYearsDay); fake_user_.SetName(\u0026#34;Fake User\u0026#34;); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(\u0026#34;Hi Fake User! Happy New Year!\u0026#34;, TitleBar(\u0026#34;2018-01-01\u0026#34;), PromptStyle::kNormal)); user_greeter_.DisplayGreeting(); }   Only verify one behavior per test. Only verify arguments that affect the correctness of the specific behavior being tested.  TEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fake_clock_.SetTime(kNewYearsDay); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(\u0026#34;Happy New Year!\u0026#34;), _, _)); user_greeter_.DisplayGreeting(); } TEST_F(DisplayGreetingTest, RenderUserName) { fake_user_.SetName(\u0026#34;Fake User\u0026#34;); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(\u0026#34;Fake User\u0026#34;), _, _)); user_greeter_.DisplayGreeting(); }  Keep Tests Focused June 11, 2018 - original post\nTesting too many scenarios at once can make it difficult to understand test and reason about the failure.\nTEST_F(BankAccountTest, WithdrawFromAccount) { Transaction transaction = account_.Deposit(Usd(5)); clock_.AdvanceTime(kMinTimeToSettle); account_.Settle(transaction); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); EXPECT_THAT(account_.Withdraw(USd(1)), IsRejected()); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(1)), IsOk()); }  Break up each scenario into its own test.\nTEST_F(BankAccountTest, CanWithdrawWithinBalance) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); } TEST_F(BankAccountTest, CannotOverdraw) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsRejected()); } TEST_F(BankAccountTest, CanOverdrawUpToOverdraftLimit) { DepositAndSettle(Usd(5)); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsOk()); }  Notice how each test only verifies the output of one call per test.\nUnderstanding Code in Review May 1, 2018 - original post\nIf you find yourself reviewing code that is difficult to understand, don't waste time reviewing it.\nbool IsOkay(int n) { bool f = false; for (int i = 2; i \u0026lt;= n; ++i) { if (n % i == 0) f = true; } return !f; }  Ask for it to be clarified.\nbool IsPrime(int n) { for (int divisor = 2; divisor \u0026lt;= n / 2; ++divisor) { if (n % divisor == 0) return false; } return true; }  Clarifying code often results in noticing improvements.\nCleanly Create Test Data February 20, 2018 - original post\nHelper methods make it easier to create test data, but they don't age well.\n// Starts simple Company company = NewCompany(kPublic); // But soon acquires more parameters Company small = NewCompany(2, 2, nullptr, kPublic); Company privately_owned = NewCompany(0, 0, nullptr, kPrivate); Company bankrupt = NewCompany(0 , 0, kPastDate, kPublic); // Or more methods Company small = NewCompanyWithEmployeesAndBoardMembers(2, 2, kPublic); Company privately_owned = NewCompanyWithType(kPrivate); Company bankrupt = NewCompanyWithBankruptcyDate(kPastDate, kPublic);  Try the builder pattern.\nCompany small = Company::Builder{}.SetEmployees(2).SetBoardMembers(2).Build(); Company privately_owned = Company::Builder{}.SetType(kPrivate).Build(); Company bankrupt = Company::Builder{}.SetBankruptcyDate(kPastDate).Build(); Company default_company = Company::Builder{}.Build(); class Company::Builder { public: Builder\u0026amp; SetEmployees(int n) { employees_ = n; return *this; } Builder\u0026amp; SetBoardMembers(int n) { board_members_ = n; return *this; } Builder\u0026amp; SetBankruptcyDate(BankruptcyDate d) { date_ = d; return *this; } Builder\u0026amp; SetType(Type t) { type_ = t; return *this; } Company Build() const { return Company(employees_, board_members_, date_, type_); } private: int employees_ = 0; int board_members_ = 0; BankruptcyDate date_ = kBeforeDate; Type type_ = kPublic; };  Only Expect State-Changing Method Calls December 11, 2017 - original post\nExpecting calls to methods that don't change state can make a test brittle, less readable, and provide a false sense of security.\nTEST(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_user_service_, IsUserActive(kUser); EXPECT_CALL(mock_permission_db_, GetPermission(kUser); EXPECT_CALL(mock_permission_db_, IsValidPermission(kReadAccess); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }  It is fine, however, to use non-state-changing methods for simulating test conditions.\nON_CALL(mock_user_service_, IsUserActive(kUser)).WillByDefault(Return(false));  With unnecessary EXPECT_CALLs removed, the test becomes:\nTest(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }  Obsessed With Primitives? November 14, 2017 - original post\nCode that relies too heavily on primitive types instead of custom abstractions can be hard to understand and maintain.\nstd::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; polygon = { std::make_pair(0, 0), std::make_pair(0, 4), std::make_pair(4, 0) }; std::pair\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::pair\u0026lt;int, int\u0026gt;\u0026gt; bounding_box = GetBoundingBox(polygon); int area = (bounding_box.second.first - bounding_box.first.first) * (bounding_box.second.second - bounding_box.first.second);  Make higher-level abstractions.\nPolygon polygon = RightTriangle(4, 4); int area = polygon.GetBoundingBox().GetArea();  This advice doesn't just apply to primitives and The STL. It's possible for any type to be too primitive for the job.\nPolygon polygon = IsoscelesRightTriangle(4); int area = polygon.GetBoundingBox().GetArea();  IdentifierNamingPostForWorldWideWebBlog October 23, 2017 - original post\nNames should be clear and precise.\nDon't mention the type in the variable name. It's OK for the name and the type match.\nstd::string name_string; std::list\u0026lt;std::time_t\u0026gt; holiday_date_list;  std::string name; std::list\u0026lt;std::time_t\u0026gt; holidays; Payments payments;  Don't use overly specific names. Get more specific if there is a need for disambiguation.\nMonster final_battle_most_dangerous_boss_monster; Payments non_typical_monthly_payments;  Monster boss; Payments payments;  Do not repeat context.\nclass AnnualHolidaySale { bool PromoteHolidaySale(); int annual_sale_rebate_; };  class AnnualHolidaySale { bool Promote(); int rebate_; }  To Comment or Not to Comment July 17, 2017 - original post\nComments are not always helpful.\n// Subtract discount from final price. final_price = (num_items * item_price) - std::min(5, num_items) * item_price * 0.1; // Filter offensive words. for (std::string word : words) { ... } int width = ...; // Width in pixels.  // Safe since height is always \u0026gt; 0. return width / height;  It's often better to make your code self-explanatory.\nprice = num_items * item_price; discount = std::min(5, num_items) * item_price * 0.1; final_price = price - discount; FilterOffensiveWords(words); Pixels width = ...; CheckArgument(height \u0026gt; 0); return width / height;  Avoid using comments to explain what code does. Use comments to explain why code does something.\nToo Many Comments on Your Code Reviews? June 19, 2017 - original post\nBefore you send out the code review:\n Review your own code first. Discuss with colleagues. Make bite-sized reviews. Add comments to the code if necessary.  When addressing code review comments:\n Review your code after addressing non-trivial comments. Understand the reviews thought process. Answer questions in the code.  Reduce Nesting, Reduce Complexity June 15, 2017 - original post\nDeeply nested code is error-prone and hurts readability.\nResponse response = server.Call(request); if (response.GetStatus() == Status::kOk) { if (!IsAuthorized(response.GetUser())) { if (response.GetEnc() == \u0026#34;utf-8\u0026#34;) { std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (!rows.empty()) { avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg; } else { throw EmptyException(); } else { throw AuthException(\u0026#39;unauthorized\u0026#39;); } } else { throw ValueException(\u0026#39;wrong encoding\u0026#39;); } } else { throw RpcException(response.GetStatus()); }  The code above could be refactored to use guard clauses.\nResponse response = server.Call(request); if (response.GetStatus() != Status::kOk) { throw RpcException(response.GetStatus()); } if (!IsAuthorized(response.GetUser())) { throw ValueException(\u0026#39;wrong encoding\u0026#39;); } if (response.GetEnc() != \u0026#34;utf-8\u0026#34;) { throw AuthException(\u0026#39;unauthorized\u0026#39;); } std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (rows.empty()) { throw EmptyException(); } avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg;  Can you spot the bug now?\nKeep Cause and Effect Clear January 31, 2017 - original post\nIt's difficult to reason about a test when the cause is hidden far away from the effect.\nclass TallyTest : public ::testing::Test { protected: void SetUp() override { tally_.Increment(\u0026#34;key1\u0026#34;, 8); tally_.Increment(\u0026#34;key2\u0026#34;, 100); tally_.Increment(\u0026#34;key1\u0026#34;, 0); tally_.Increment(\u0026#34;key1\u0026#34;, 1); } Tally tally_; } // 200 lines of code  TEST_F(TallyTest, IncrementExistingKey) { EXPECT_EQ(9, tally_.Get(\u0026#34;key1\u0026#34;)); }  Write tests where the effects immediately follow the causes.\nclass TallyTest : public ::testing::Test { protected: Tally tally_; } TEST_F(TallyTest, NewKey) { tally_.Increment(\u0026#34;key\u0026#34;, 100); EXPECT_EQ(100, tally_.Get(\u0026#34;key\u0026#34;)); } TEST_F(TallyTest, ExistingKey) { tally_.Increment(\u0026#34;key\u0026#34;, 8); tally_.Increment(\u0026#34;key\u0026#34;, 1); EXPECT_EQ(9, tally_.Get(\u0026#34;key\u0026#34;)); } TEST_F(TallyTest, IncrementByZeroDoesNothing) { tally_.Increment(\u0026#34;key\u0026#34;, 8); tally_.Increment(\u0026#34;key\u0026#34;, 0); EXPECT_EQ(8, tally_.Get(\u0026#34;key\u0026#34;)); }  It may require a bit more code, but it's easier to read and maintain.\nWhat Makes a Good End-to-End Test? September, 2016 - original post\nEnd-to-end tests give confidence about the health of the system when it is in a near production state, but they tend to be more flaky and expensive to maintain.\nTo be cost effective, end-to-end tests should focus on aspects of the system that cannot be evaluated by smaller tests. Minor and/or frequently changing details like error messages or visual layouts should not effect the test.\nChange-Detector Tests Considered Harmful January 27, 2015 - original post\nTests that break in response to any change to production code without verifying correct behavior only add to maintenance costs without catching defects.\nvoid Processor::Process(Work w) { first_part_.Process(w); second_part_.Process(w); } TEST(ProcessorTest, ProcessWork) { MockFirstPart part1; MockSecondPart part2; Processor p(part1, part2); Work w; EXPECT_CALL(part1, Process(w)); EXPECT_CALL(part2, Process(w)); p.Process(w); }  Tests like these should either be re-written or deleted.\nPrefer Testing Public APIs Over Implementation-Detail Classes January 14, 2015 - original post\nPublic APIs can be called by many users. Implementation details are only called by public APIs. If the public APIs are well tested, as they should be, then the implementation details will get tested by association.\nHeavy testing against implementation details can cause a couple problems:\n Unlike public APIs, implementation details are vulnerable to refactoring. Tests for implementation details can fail even though the behavior from the public API is fine. Testing implementation details can give false confidence. Even if an implementation detail is well tested, that doesn't mean the pubic API behaves properly.  Writing Descriptive Test Names October 16, 2014 - original post\nVague test names make it hard to keep track of what is tested.\nTEST_F(IsUserLockedOutTest, InvalidLogin) { authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_TRUE(authenticator_.IsUserLockedOut(username_)); }  Descriptive test names make it easy to tell what behavior is broken without looking at code. Also, the length of a good test name helps indicate when a test needs to be split apart.\nTEST_F(IsUserLockedOutTest, ShouldLockOutUserAfterThreeInvalidLoginAttempts) { // ... }  A test's name should be all you need to know to understand the behavior being tested. Make sure the name contains both the scenario being tested and the expected outcome.\nDon't Put Logic in Tests July 31, 2014 - original post\nTests should be simple by stating I/O directly rather than computing them.\nTEST(NavigatorTest, ShouldNavigateToPhotosPage) { const std::string baseUrl = \u0026#34;http://plus.google.com/\u0026#34;; Navigator nav(baseUrl); nav.GoToPhotosPage(); EXPECT_EQ(baseUrl + \u0026#34;/u/0/photos\u0026#34;, nav.GetCurrentUrl()); }  Even a simple string concatenation can lead to bugs.\nTEST(NavigatorTest, ShouldNavigateToPhotosPage) { Navigator nav(\u0026#34;http://plug.google.com/\u0026#34;); nav.GoToPhotosPage(); EXPECT_EQ(\u0026#34;http://plus.google.com//u/0/photos\u0026#34;, nav.GetCurrentUrl()); }  If a test requires logic, move that logic out of the test body into utilities and helper functions and write tests for them too.\nRisk-Driven Testing May 30, 2014 - original post\nBlindly writing tests can lead to a false sense of security or wasted effort. Before writing tests, think about testing. Small tests are cheap, larger tests protect core use-cases and integration. Manual testing can sometimes be the cheapest, most effective option.\nEffective Testing May 7, 2014 - original post\nTo be effective, a test maximizes three important qualities:\n Fidelity - Sensitive to defects in the code under test. Resilience - Fails only when a breaking change is made to the code under test. Precision - Upon failure reports exactly where the defect lies.  Test Behaviors, Not Methods A single method can exhibit many behaviors. Likewise, a single behavior can span multiple methods.\nIt can be harmful to think that tests and public methods should have a 1:1 relationship.\nTEST_F(TransactionProcessorTest, ProcessTransaction) { User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2)); transaction_processor_.ProcessTransaction(user, Transaction(\u0026#34;Pile of Beanie Babies\u0026#34;, Dollars(3))); EXPECT_THAT(ui_.GetText(), HasSubstr(\u0026#34;You bought a Pile of Beanie Babies\u0026#34;)); EXPECT_EQ(user.GetEmails().size(), 1); EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), \u0026#34;Your balance is low\u0026#34;); }  Each test should verify one behavior. Each method may take several tests to verify.\nTEST_F(TransactionProcessorTest, ShouldDisplayNotification) { transaction_processor_.ProcessTransaction(User(), Transaction(\u0026#34;Pile of Beanie Babies\u0026#34;)); EXPECT_THAT(ui_.GetText(), HasSubstr(\u0026#34;You bought a Pile of Beanie Babies\u0026#34;)); } TEST_F(TransactionProcessorTest, ShouldSendEmailWhenBalanceIsLow) { User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2)); transaction_processor_.ProcessTransaction(user, Transaction(Dollars(3))); EXPECT_EQ(user.GetEmails().size(), 1); EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), \u0026#34;Your balance is low\u0026#34;); }  What Makes a Good Test? Tests provide more than verification. They also serve as documentation.\nAs a source of documentation, test should not be distracting or hide information.\nTEST(CalculatorTest, ShouldPerformAddition) { Calculator calculator(RoundingStrategy(), \u0026#34;unused\u0026#34;, kEnableCosinFeature, 0.01, kCalculusEngine, false); int result = calculator.DoComputation(MakeTestComputation()); EXPECT_EQ(result, 5); }  TEST_(CalculatorTest, ShouldPerformAddition) { const int result = calculator_.DoComputation(MakeAdditionComputation(2, 3)); EXPECT_EQ(result, 5); }  Test Behavior, Not Implementation August 5, 2013 - original post\nExcept where explicitly intended, tests should work independent of the implementation details being tested.\nclass Calculator { public: int Add(int a, int b) { return a + b; } }; class Calculator { public: int Add(int a, int b) { Adder adder = adder_factory_.CreateAdder(); ReturnValue return_value = adder.Compute(Number(a), Number(b)); return return_value.ConvertToInteger(); } private: AdderFactory adder_factory_; }; TEST_F(CalculatorTest, ShouldAddIntegers) { EXPECT_EQ(3, calculator_.Add(2, 1)); EXPECT_EQ(2, calculator_.Add(2, 0)); EXPECT_EQ(1, calculator_.Add(2, -1)); } Know Your Test Doubles July 18, 2013 - original post\nA test double is an object that can stand in for a real object in test. The most common types of test doubles are:\n  Stub - Returns a specific values to promote a specific state.\nAccessManager access_manager(kStubAuthenticationService); ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(false)); EXPECT_FALSE(access_manager.UserHasAccess(kUserId)); ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(true)); EXPECT_TRUE(access_manager.UserHasAccess(kUserId));   Mock - Sets expectations about how other objects should interact with it.\nAccessManager access_manager(mockAuthenticationService); EXPECT_CALL(mockAuthenticationService, IsAuthenticated(kUserId)); access_manager.UserHasAccess(kUserId);   Fake - A lightweight implementation when the real implementation is unsuitable for test.\nFakeAuthenticationService fake_authentication_service; AccessManager access_manager(fake_authentication_service); EXPECT_FALSE(access_manager.UserHasAccess(kUserId)); fake_authentication_service.AddAuthenticatedUser(kUser); EXPECT_TRUE(access_manager.UserHasAccess(kUserId));   Fake Your Way To Better Tests June 28, 2013 - original post\nSuppose you would like to test your blog platform API, but you don't want your tests talking to a remote server.\nvoid DeletePostsWithTag(const Tag\u0026amp; tag) { for (const Post post : blog_service_-\u0026gt;GetAllPosts()) { if (post.HasTag(tag)) { blog_service_-\u0026gt;DeletePost(post.GetId()); } } } A fake is a lightweight implementation of an API that behaves like the real implementation, but isn't suitable for production.\nclass FakeBlogService : public BlogService { public: void AddPost(const Post\u0026amp; post) { posts.insert(post); } void DeletePost(const int id) { for (auto\u0026amp; post : posts) { if (post.GetId() == id) { posts.erase(post); return; } } } std::set\u0026lt;Post\u0026gt; GetAllPosts() const { return posts; } private: std::set\u0026lt;Post\u0026gt; posts; }; Fakes should be created and maintained by the person or team that owns the real implementation.\nFakes should have their own tests to make sure they behave like the real implementation.\nDon't Overuse Mocks May 28, 2013 - original post\nMocks are powerful, but easy to abuse.\nTEST_F(PaymentProcessorTest, ShouldChargeCreditCard) { PaymentProcessor payment_processor(mock_credit_card_server_); InSequence s; EXPECT_CALL(mock_credit_card_server_, IsServerAvailable()).WillOnce(Return(true)); EXPECT_CALL(mock_credit_card_server_, BeginTransaction()).WillOnce(Return(mock_transaction_manager_)); EXPECT_CALL(mock_transaction_manager_, GetTransaction()).WillOnce(Return(transaction_)); EXPECT_CALL(mock_credit_card_server_, Pay(transaction_, credit_card_, 500)).WillOnce(Return(mock_payment_)); EXPECT_CALL(mock_payment_, IsOverMaxBalance()).WillOnce(Return(false)); payment_processor.ProcessPayment(credit_card_, Dollars(500)); }  Overusing mocks makes tests harder to understand, maintain, and provides less insurance that your code is working properly.\nIf you don't need a mock, don't use one. Understanding when to use a mock comes from understanding what you want to test.\nTEST_F(PaymentProcessorTest, ShouldChargeCreditCard) { PaymentProcessor payment_processor(credit_card_server_); payment_processor.ProcessPayment(credit_card_, Dollars(500)); EXPECT_EQ(credit_card_server_.GetMostRecentCharge(credit_card_), 500); }  Testing State vs. Testing Interactions March 22, 2013 - original post\n  Testing State - Verifying the code under test returns the correct results.\nTEST(NumberSorterTest, ShouldSortIntegers) { NumberSorter number_sorter({quicksort, bubblesort}); std::vector\u0026lt;int\u0026gt; numbers = {3, 1, 2}; EXPECT_EQ({1, 2, 3}, number_sorter.SortNumbers(numbers)); }   Testing Interaction - Verifying the code under test calls methods correctly.\nTEST(NumberSorterTest, ShouldUseQuicksort) { NumberSorter number_sorter({mock_quicksort, mock_bubblesort}); std::vector\u0026lt;int\u0026gt; numbers = {3, 1, 2}; EXPECT_CALL(mock_quicksort, Sort(numbers); number_sorter.SortNumbers(numbers); }   Most of the time you want to test state. Occasionally interactions need to be tested when the number of calls or order of calls matter.\nCode coverage goal: 80% and no less! July 20, 2010 - original post\nEarly one morning, a young programmer asked the great master, “I am ready to write some unit tests. What code coverage should I aim for?”\nThe great master replied, “Don’t worry about coverage, just write some good tests.”\nThe young programmer smiled, bowed, and left.\nLater that day, a second programmer asked the same question. The great master pointed at a pot of boiling water and asked, “How many grains of rice should I put in that pot?”\nThe programmer, looking puzzled, replied, “How can I possibly tell you? It depends on how many people you need to feed, how hungry they are, what other food you are serving, how much rice you have available, and so on.”\n“Exactly,” said the great master.\nThe second programmer smiled, bowed, and left.\nToward the end of the day, a third programmer came and asked the same question about code coverage.\n“Eighty percent and no less!” Replied the master in a stern voice, pounding his fist on the table.\nThe third programmer smiled, bowed, and left.\nAfter this last reply, a young apprentice approached the great master, “Great master, today I overheard you answer the same question about code coverage with three different answers. Why?”\nThe great master stood up from his chair. “Come get some fresh tea with me and let’s talk about it.” After they filled their cups with smoking hot green tea, the great master began:\n“The first programmer is new and just getting started with testing. Right now he has a lot of code and no tests. He has a long way to go; focusing on code coverage at this time would be depressing and quite useless. He’s better off just getting used to writing and running some tests. He can worry about coverage later.\n\u0026ldquo;The second programmer, on the other hand, is quite experienced both at programming and testing. When I replied by asking her how many grains of rice I should put in a pot, I helped her realize that the amount of testing necessary depends on a number of factors, and she knows those factors better than I do – it’s her code after all. There is no single, simple, answer, and she’s smart enough to handle the truth and work with that.”\n“I see,” said the young apprentice, “but if there is no single simple answer, then why did you tell the third programmer ‘Eighty percent and no less’?”\nThe great master laughed so hard and loud that his belly, evidence that he drank more than just green tea, flopped up and down. “The third programmer wants only simple answers – even when there are no simple answers … and then does not follow them anyway.”\nThe young apprentice and the grizzled great master finished drinking their tea in contemplative silence.\nData Driven Traps! September 4, 2008 - original post\nData driven tests are efficient, but easy to abuse.\nstruct TestData { const std::string word; const bool is_word; }; const std::vector\u0026lt;TestData\u0026gt; test_data = { {\u0026#34;milk\u0026#34;, true}, {\u0026#34;centre\u0026#34;, false}, {\u0026#34;jklm\u0026#34;, false}, }; TEST(IsWordTest, TestEverything) { for (const auto\u0026amp; entry : test_data) { EXPECT_EQ(IsWord(entry.word), entry.is_word); } }  Data-driven tests make debugging and understanding failures, let alone false positives, more difficult.\nAs the code grows in complexity, data tends to grow even faster. It quickly becomes impossible to discern what behavior each piece of data is meant to test.\nconst std::vector\u0026lt;Locale\u0026gt; locales = { Word::US, Word::UK, Word::France, ... }; struct TestData { std::string word; bool[kNumLocales] is_word; }; const std::vector\u0026lt;TestData\u0026gt; test_data = { {\u0026#34;milk\u0026#34;, {true, true, false, ...}, {\u0026#34;centre\u0026#34;, {false, true, true, ...}}, {\u0026#34;jklm\u0026#34;, {false, false, false, ...}}, }; TEST(IsWordTest, TestEverything) { for (const auto\u0026amp; entry : test_data) { for (const auto* locale: locales) { EXPECT_EQ(IsWord(entry.word, locale), entry.is_word); } } }  Instead, think critically about what behaviors are worth testing.\nTEST(IsWordTest, ShouldExistInMultipleLocales) { EXPECT_TRUE(IsWord(\u0026#34;milk\u0026#34;, Word::US)); EXPECT_TRUE(IsWord(\u0026#34;milk\u0026#34;, Word::UK)); EXPECT_FALSE(IsWord(\u0026#34;milk\u0026#34;, Word::France)); } TEST(IsWordTest, ShouldNotExist) { // \u0026#34;jklm\u0026#34; test not repeated as it uses the same code path  EXPECT_FALSE(IsWord(\u0026#34;jklm\u0026#34;, Word::US)); }  Sleeping != Synchronization August 21, 2008 - original post\nBeware of sleep. sleep should never be used for synchronization, or in test.\nclass CoffeeMaker { public: virtual ~CoffeeMaker() = default; virtual void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) = 0; }; class Intern : public CoffeeMaker { public: void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) { // make coffee, hopefully within 60 seconds.  callback(); } }; class Employee { public: void DrinkCoffee() { caffeinated_ = true; } bool IsCaffeinated() { return caffeinated_; } void DemandCoffee(CoffeeMaker\u0026amp; cm) { std::thread t(\u0026amp;CoffeeMaker::MakeCoffee, \u0026amp;cm, std::bind(\u0026amp;Employee::DrinkCoffee, this)); t.detach(); } private: bool caffeinated_ = false; }; TEST(EmployeeTest, ShouldBeCaffeinatedOnlyAfterDrinkingCoffee) { Employee e; Intern i; e.DemandCoffee(i); EXPECT_FALSE(e.IsCaffeinated()); std::this_thread::sleep_for(60s); EXPECT_TRUE(e.IsCaffeinated()); }  Code that sleeps can be improved by waiting on a std::future or a std::condition_variable. As always, if your waiting on a non-trivial operation, like Intern::MakeCoffee, use a fake.\nclass FakeIntern : public CoffeeMaker { public: void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mut_); cv_.wait(lock, [this] { return ready_; }); callback(); done_ = true; lock.unlock(); cv_.notify_one(); } void SignalAndWait() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mut_); ready_ = true; cv_.notify_one(); cv_.wait(lock, [this] { return done_; }); } private: bool ready_ = false; bool done_ = false; std::condition_variable cv_; std::mutex mut_; }; TEST(EmployeeTest, ShouldBeCaffeinatedOnlyAfterDrinkingCoffee) { Employee e; FakeIntern i; e.DemandCoffee(i); EXPECT_FALSE(e.IsCaffeinated()); i.SignalAndWait(); EXPECT_TRUE(e.IsCaffeinated()); }  Defeat \u0026ldquo;Static Cling\u0026rdquo; June 26, 2008 - original post\nStatic functions, like this singleton GetInstance method, are a sign of tight coupling.\nclass MyObject { public: int DoSomething(int id) { return TheirEntity::GetInstance().GetSomething(id); } }; There is a way around this using the Repository Pattern.\nclass TheirEntityRepository { public: virtual ~TheirEntityRepository() = default; virtual TheirEntity\u0026amp; GetInstance() = 0; // Other static methods here }; class TheirEntityStaticRepository : public TheirEntityRepository { public: TheirEntity\u0026amp; GetInstance() { return TheirEntity::GetInstance(); } }; class MyObject { public: explicit MyObject(std::unique_ptr\u0026lt;TheirEntityRepository\u0026gt; repository) : repository_(std::move(repository)) {} int DoSomething(int id) { return repository_-\u0026gt;GetInstance().GetSomething(); } private: std::unique_ptr\u0026lt;TheirEntityRepository\u0026gt; repository_; }; All thats left is to derive a MockTheirEntityRepository suitable for your testing needs.\nTestable Contracts Make Exceptional Neighbors May 28, 2008 - original post\nModify external visible state only after completing all operations which could possibly fail.\nbool SomeCollection::GetObjects(std::vector\u0026lt;Object\u0026gt;\u0026amp; objects) const { objects.clear(); for (const auto\u0026amp; object : collection_) { if (object.IsFubarred()) return false; objects.push_back(object); } return true; }  In these situations, the swap trick comes in handy.\nbool SomeCollection::GetObjects(std::vector\u0026lt;Object\u0026gt;\u0026amp; objects) const { std::vector\u0026lt;Object\u0026gt; known_good_objects; for (const auto\u0026amp; object : collection_) { if (object.IsFubarred()) return false; known_good_objects.push_back(object); } objects.swap(known_good_objects); return true; }  Now, the caller has good objects on success, or unchanged objects on failure.\nUnderstanding Your Coverage Data March 6, 2008 - original post\nHigh test coverage is necessary but not sufficient.\nUse your test coverage results to look for unexpected coverage patterns, which usually indicate bugs, and add test cases to address them.\nToo Many Tests February 21, 2008 - original post\nHow many tests? Answering this question requires a good grasp of the context.\nvoid Decide(int32_t a, int32_t b, int32_t c, int32_t d, int32_t e, int32_t d) { if (a \u0026gt; b || c \u0026gt; d || e \u0026gt; f) { DoOneThing(); } else { DoAnother(); } }  Testing every possible input would require 2192tests. Thats too many. Testing enough to get full line coverage would require 2 tests. Thats too few. Testing each logical expression (e.g a \u0026gt; b, a == b, a \u0026lt; b) independently is 27 tests. Still probably too many.  More context can focus the decision.\nvoid Decide(int32_t a, int32_t b, int32_t c, int32_t d, int32_t e, int32_t d) { if (TallerThan(a, b) || HarderThan(c, d) || HeavierThan(e, f)) { DoOneThing(); } else { DoAnother(); } } bool TallerThan(int32_t a, int32_t b) { return a \u0026gt; b; } bool HarderThan(int32_t c, int32_t d) { return d \u0026gt; d; } bool HeavierThan(int32_t e, int32_t f) { return e \u0026gt; f; } Testing the cases where each extracted function is true, they all are false, and writing 2 tests for each of the extracted functions would require 4 + 3*2 = 10 tests. Considering the number of inputs, thats just enough tests.\nAvoiding Friend Twister in C++ October 30, 2007 - original post\n\u0026ldquo;Testing private members requires more friend contortions than a game of Twister®.\u0026rdquo;\nIf you find yourself saying that, theres a better way.\n// include/my_project/dashboard.h  class Dashboard { private: // Declaration of functions getResults(), GetResultsFromCache(),  // GetResultsFromDatabase(), and CountPassFail()  std::unique_ptr\u0026lt;Database\u0026gt; database_; // instantiated in constructor  friend class DashboardTest; // one friend declaration per test fixture };  Instead, make a helper class by extracting a helper class (a variant of the Pimple idiom).\nTo preserve privacy, the helper class is tucked away in a private implementation directory separate from the public API.\n// include/my_project/dashboard.h  class ResultsLog; // Foreword declare extracted helper interface  class Dashboard { public: explicit Dashboard(std::unique_ptr\u0026lt;ResultsLog\u0026gt; results) : results_(std::move(results)) {} private: std::unique_ptr\u0026lt;ResultsLog\u0026gt; results_; }; // src/results_log.h  class ResultsLog { public: // Declaration of functions getResults(), GetResultsFromCache(),  // GetResultsFromDatabase(), and CountPassFail() }; // src/live_results_log.h  class LiveResultsLog : public ResultsLog { public: explicit LiveResultsLog(std::shared_ptr\u0026lt;Database\u0026gt; database) : database_(std::move(database)) {} };  As an added bonus, now you can inject a MockResultsLog or a FakeDatabase for testing the Dashboard class.\nRefactoring Tests in the Red April 26, 2007 - original post\nAs your test suite grows, you will find yourself needing to refactor your tests. However, your tests don't have tests!\nOne thing you can do is intentionally break the test, refactor the test, and make sure the test still fails as expected.\nJust remember to revert your code under test!\n"
}]
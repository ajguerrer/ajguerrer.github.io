[
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/",
	"title": "Google Testing Blog",
	"tags": [],
	"description": "",
	"content": " Google Google Testing Blog Notes taken from Google Testing Blog with examples in C++ and the Google Test framework.\n"
},
{
	"uri": "https://ajguerrer.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/",
	"title": "Notebook",
	"tags": [],
	"description": "",
	"content": " Andrew Guerrero Notebook Welcome! You have stumbled upon Andrew Guerrero\u0026rsquo;s notebook.\nIf you are looking for some notes on software development and engineering, then you have come to the right place.\n"
},
{
	"uri": "https://ajguerrer.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/tott/",
	"title": "Testing on the Toilet",
	"tags": [],
	"description": "",
	"content": " Exercise Service Call Contracts in Tests November 27, 2018 - original post\nIf the code under test relies on the contract of a service, prefer exercising the service call instead of mocking it out. Some service owners provide a fake. Otherwise, use a hermetic server.\nMake Interfaces Hard to Misuse July 25, 2018 - original post\nDon\u0026rsquo;t push the responsibility of maintaining invariants on the caller.\nclass Vector { explicit Vector(int num_slots); int RemainingSlots() const; void AddSlots(int num_slots); void Insert(int value); };   Caller needs to check RemainingSlots and if 0, AddSlots in order for Insert to work properly.\nInsert could automatically manage slots.\nclass Vector { explicit Vector(int num_slots); void Insert(int value); };   Other examples:\n Initialize / Deitialize functions. Allowing partially created objects. Parameters that can have invalid values.  Sometimes it\u0026rsquo;s not practical to have a foolproof interface. In those cases rely on static analysis or documentation.\nOnly Verify Relevant Method Arguments June 26, 2018 - original post\nTests become fragile when they expect exact values on irrelevant arguments.\nTEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fakeClock_.SetTime(kNewYearsDay); fakeUser_.SetName(\u0026quot;Fake User\u0026quot;); EXPECT_CALL(mockUserPrompter_, UpdatePrompt(\u0026quot;Hi Fake User! Happy New Year!\u0026quot;, TitleBar(\u0026quot;2018-01-01\u0026quot;), PromptStyle::kNormal)); userGreeter_.DisplayGreeting(); }   Only verify one behavior per test. Only verify arguments that affect the correctness of the specific behavior being tested.\nTEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fakeClock_.SetTime(kNewYearsDay); EXPECT_CALL(mockUserPrompter_, UpdatePrompt(HasSubstr(\u0026quot;Happy New Year!\u0026quot;), _, _)); userGreeter_.DisplayGreeting(); } TEST_F(DisplayGreetingTest, RenderUserName) { fakeUser_.SetName(\u0026quot;Fake User\u0026quot;); EXPECT_CALL(mockUserPrompter_, UpdatePrompt(HasSubstr(\u0026quot;Fake User\u0026quot;), _, _)); userGreeter_.DisplayGreeting(); }   Keep Tests Focused June 11, 2018 - original post\nTesting too many scenarios at once can make it difficult to understand test and reason about the failure.\nTEST_F(BankAcountTest, WidthdrawFromAccount) { Transaction transaction = acceunt_.Deposit(Usd(5)); clock_.AdvanceTime(kMinTimeToSettle); account_.Settle(transaction); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); EXPECT_THAT(account_.Withdraw(USd(1)), IsRejected()); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(1)), IsOk()); }   Break up each scenario into its own test.\nTEST_F(BankAccountTest, CanWithdrawWithinBalance) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); } TEST_F(BankAccountTest, CannotOverdraw) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsRejected()); } TEST_F(BankAccountTest, CanOverdrawUpToOverdraftLimit) { DepositAndSettle(Usd(5)); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsOk()); }   Notice how each test only asserts on the output of one call per test.\nUnderstanding Code in Review May 1, 2018 - original post\nIf you find yourself reviewing code that is difficult to understand, don\u0026rsquo;t waste time reviewing it.\nbool IsOkay(int n) { bool f = false; for (int i = 2; i \u0026lt;= n; ++i) { if (n % i == 0) f = true; } return !f; }   Ask for it to be clarified.\nbool IsPrime(int n) { for (int divisor = 2; divisor \u0026lt;= n / 2; ++divisor) { if (n % divisor == 0) return false; } return true; }   Clarifying code often results in noticing improvements.\nCleanly Create Test Data Febuary 20, 2018 - original post\nHelper methods make it easier to create test data, but they don\u0026rsquo;t age well.\n// Starts simple Company company = NewCompany(kPublic); // But soon acquires more parameters Company small = NewCompany(2, 2, nullptr, kPublic); Company privately_owned = NewCompany(0, 0, nullptr, kPrivate); Company bankrupt = NewCompany(0 , 0, kPastDate, kPublic); // Or more methods Company small = NewCompanyWithEmployeesAndBoardMembers(2, 2, kPublic); Company privately_owned = NewCompanyWithType(kPrivate); Company bankrupt = NewCompanyWithBankruptcyDate(kPastDate, kPublic);   Try the builder pattern.\nCompany small = Company::Builder{}.SetEmployees(2).SetBoardMembers(2).Build(); Company privately_owned = Company::Builder{}.SetType(kPrivate).Build(); Company bankrupt = Company::Builder{}.SetBankruptcyDate(kPastDate).Build(); Company default_company = Company::Builder{}.Build(); class Company::Builder { public: Builder\u0026amp; SetEmployees(int n) { employees_ = n; return *this; } Builder\u0026amp; SetBoardMembers(int n) { board_members_ = n; return *this; } Builder\u0026amp; SetBankruptcyDate(BankruptcyDate d) { date_ = d; return *this; } Builder\u0026amp; SetType(Type t) { type_ = t; return *this; } Company Build() const { return Company(employees_, board_members_, date_, type_); } private: int employees_ = 0; int board_members_ = 0; BankruptcyDate date_ = kBeforeDate; Type type_ = kPublic; };   Only Expect State-Changing Method Calls December 11, 2017 - original post\nExpecting calls to methods that don\u0026rsquo;t change state can make a test brittle, less readable, and provide a false sense of security.\nTEST(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_user_service_, IsUserActive(kUser); EXPECT_CALL(mock_permission_db_, GetPermission(kUser); EXPECT_CALL(mock_permission_db_, IsValidPermission(kReadAccess); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }   Instead of expecting non-state-changing methods to be called, use them to verify state.\nEXPECT_FALSE(IsUserActive(kUser));   With unnecessary EXPECT_CALLs removed, the test becomes:\nTest(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }   Obsessed With Primitives? November 14, 2017 - original post\nCode that relies too heavily on primitive types instead of custom abstractions can be hard to understand and maintain.\nstd::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; polygon = { std::make_pair(0, 0), std::make_pair(0, 4), std::make_pair(4, 0) }; std::pair\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::pair\u0026lt;int, int\u0026gt;\u0026gt; bounding_box = GetBoundingBox(polygon); int area = (bounding_box.second.first - bounding_box.first.first) * (bounding_box.second.second - bounding_box.first.second);   Make higher-level abstractions.\nPolygon polygon = RightTriangle(4, 4); int area = polygon.GetBoundingBox().GetArea();   This advice doesn\u0026rsquo;t just apply to primitives and The STL. It\u0026rsquo;s possible for any type to be too primitive for the job.\nPolygon polygon = IsoscelesRightTriangle(4); int area = polygon.GetBoundingBox().GetArea();   IdentifierNamingPostForWorldWideWebBlog October 23, 2017 - original post\nNames should be clear and precise.\nDon\u0026rsquo;t mention the type in the variable name. It\u0026rsquo;s OK for the name and the type match.\nstd::string nameString; std::list\u0026lt;std::time_t\u0026gt; holidayDateList;   std::string name; std::list\u0026lt;std::time_t\u0026gt; holidays; Payments payments;   Don\u0026rsquo;t use overly specific names. Get more specific if there is a need for disambiguation.\nMonster final_battle_most_dangerous_boss_monster; Payments non_typical_monthly_payments;   Monster boss; Payments payments;   Do not repeat context.\nclass AnnualHolidaySale { bool PromoteHolidaySale(); int annual_sale_rebate_; };   class AnnualHolidaySale { bool Promote(); int rebate_; }   To Comment or Not to Comment July 17, 2017 - original post\nComments are not always helpful.\n// Subtract discount from final price. final_price = (num_items * item_price) - std::min(5, num_items) * item_price * 0.1; // Filter offensive words. for (std::string word : words) { ... } int width = ...; // Width in pixels. // Safe since height is always \u0026gt; 0. return width / height;   It\u0026rsquo;s often better to make your code self-explanatory.\nprice = num_items * item_price; discount = std::min(5, num_items) * item_price * 0.1; final_price = price - discount; filterOffensiveWords(words); Pixels width = ...; checkArgument(height \u0026gt; 0); return width / height;   Avoid using comments to explain what code does. Use comments to explain why code does something.\nToo Many Comments on Your Code Reviews? June 19, 2017 - original post\nBefore you send out the code review:\n Review your own code first. Discuss with colleagues. Make bite-sized reviews. Add comments to the code if necessary.  When addressing code review comments:\n Review your code after addressing non-trivial comments. Understand the reviews thought process. Answer questions in the code.  Reduce Nesting, Reduce Complexity June 15, 2017 - original post\nDeeply nested code is error-prone and hurts readability.\nResponse response = server.Call(request); if (response.GetStatus() == Status::kOk) { if (!IsAuthorized(response.GetUser())) { if (response.GetEnc() == \u0026quot;utf-8\u0026quot;) { std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (!rows.empty()) { avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg; } else { throw EmptyException(); } else { throw AuthException('unauthorized'); } } else { throw ValueException('wrong encoding'); } } else { throw RpcException(response.GetStatus()); }   The code above could be refactored using a technique called guard clause.\nResponse response = server.Call(request); if (response.GetStatus() != Status::kOk) { throw RpcException(response.GetStatus()); } if (!IsAuthorized(response.GetUser())) { throw ValueException('wrong encoding'); } if (response.GetEnc() != \u0026quot;utf-8\u0026quot;) { throw AuthException('unauthorized'); } std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (rows.empty()) { throw EmptyException(); } avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg;   Can you spot the bug now?\nKeep Cause and Effect Clear January 31, 2017 - original post\nIt\u0026rsquo;s difficult to reason about a test when the cause is hidden far away from the effect.\nclass TallyTest : public ::testing::Test { protected: void SetUp() override { tally_.Increment(\u0026quot;key1\u0026quot;, 8); tally_.Increment(\u0026quot;key2\u0026quot;, 100); tally_.Increment(\u0026quot;key1\u0026quot;, 0); tally_.Increment(\u0026quot;key1\u0026quot;, 1); } Tally tally_; } // 200 lines of code TEST_F(TallyTest, IncrementExistingKey) { EXPECT_EQ(9, tally_.Get(\u0026quot;key1\u0026quot;)); }   Write tests where the effects immediately follow the causes.\nclass TallyTest : public ::testing::Test { protected: Tally tally_; } TEST_F(TallyTest, NewKey) { tally_.Increment(\u0026quot;key\u0026quot;, 100); EXPECT_EQ(100, tally_.Get(\u0026quot;key\u0026quot;)); } TEST_F(TallyTest, ExistingKey) { tally_.Increment(\u0026quot;key\u0026quot;, 8); tally_.Increment(\u0026quot;key\u0026quot;, 1); EXPECT_EQ(9, tally_.Get(\u0026quot;key\u0026quot;)); } TEST_F(TallyTest, IncrementByZeroDoesNothing) { tally_.Increment(\u0026quot;key\u0026quot;, 8); tally_.Increment(\u0026quot;key\u0026quot;, 0); EXPECT_EQ(8, tally_.Get(\u0026quot;key\u0026quot;)); }   It may require a bit more code, but it\u0026rsquo;s easier to read and maintain.\nWhat Makes a Good End-to-End Test? September, 2016 - original post\nEnd-to-end tests give confidence about the health of the system when it is in a near production state, but they tend to be more flaky and expensive to maintain.\nTo be cost effective, end-to-end tests should focus on aspects of the system that cannot be evaluated by smaller tests. Minor and/or frequently changing details like error messages or visual layouts should not effect the test.\nChange-Detector Tests Considered Harmful January 27, 2015 - original post\nTests that break in response to any change to production code without verifying correct behavior only add to maintenance costs without catching defects.\nvoid Processor::Process(Work w) { first_part_.Process(w); second_part_.Process(w); } TEST(ProcessorTest, ProcessWork) { MockFirstPart part1; MockSecondPart part2; Processor p(part1, part2); Work w; EXPECT_CALL(part1, Process(w)); EXPECT_CALL(part2, Process(w)); p.Process(w); }   Tests like these should either be re-written or deleted.\nPrefer Testing Public APIs Over Implementation-Detail Classes January 14, 2015 - original post\nPublic APIs can be called by many users. Implementation details are only called by public APIs. If the public APIs are well tested, as they should be, then the implementation details will get tested by association.\nHeavy testing against implementation details can cause a couple problems:\n Unlike public APIs, implementation details are vulnerable to refactoring. Tests for implementation details can fail even though the behavior from the public API is fine. Testing implementation details can give false confidence. Even if an implementation detail is well tested, that doesn\u0026rsquo;t mean the pubic API behaves properly.  Writing Descriptive Test Names October 16, 2014 - original post\nVague test names make it hard to keep track of what is tested.\nTEST_F(IsUserLockedOutTest, InvalidLogin) { authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_TRUE(authenticator_.IsUserLockedOut(username_)); }   Descriptive test names make it easy to tell what behavior is broken without looking at code. Also, test names naturally become longer making for a good indicator that a test needs to be split apart.\nTEST_F(IsUserLockedOutTest, ShouldLockOutUserAfterThreeInvalidLoginAttempts) { // ... }   You should be able to understand the behavior being tested just by reading the test name. Make sure the test names contain both the scenario being tested and the expected outcome.\n"
}]
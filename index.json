[
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/",
	"title": "Google Testing Blog",
	"tags": [],
	"description": "",
	"content": " Google Google Testing Blog Notes taken from Google Testing Blog with examples in C++ and the Google Test framework.\n "
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/blog/",
	"title": "Blog Notes",
	"tags": [],
	"description": "",
	"content": " Test Reliability  Test binary size and RAM have strong correlations on whether a test is flaky. This includes the influence any third-party testing tools have. - Source  Productivity  Releasing often give teams an incentive to automate testing and reduce coupling with the rest of the system. - Source  Code Health  When a team provides fakes and writes tests for them, they become clients of their own software. Experiencing the perspective of the client gives the team an incentive to make their API easier to use. - Source  "
},
{
	"uri": "https://ajguerrer.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/",
	"title": "Notebook",
	"tags": [],
	"description": "",
	"content": " Andrew Guerrero Notebook Welcome! You have stumbled upon Andrew Guerrero\u0026rsquo;s notebook.\nIf you are looking for notes on software development and engineering, then you have come to the right place.\n "
},
{
	"uri": "https://ajguerrer.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ajguerrer.github.io/google-testing-blog/tott/",
	"title": "Testing on the Toilet",
	"tags": [],
	"description": "",
	"content": " This page contains portable (potable?) bits of testing best-practices that will keep you riveted to your seat.\nExercise Service Call Contracts in Tests November 27, 2018 - original post\nIf the code under test relies on the contract of a service, prefer exercising the service call instead of mocking it out. Some service owners provide a fake. Otherwise, use a hermetic server.\nMake Interfaces Hard to Misuse July 25, 2018 - original post\nDon\u0026rsquo;t push the responsibility of maintaining invariants on the caller.\nclass Vector { explicit Vector(int num_slots); int RemainingSlots() const; void AddSlots(int num_slots); void Insert(int value); };   In the code above, the caller needs to check RemainingSlots, and if 0, AddSlots in order for Insert to work properly.\nInstead, Insert could automatically manage slots.\nclass Vector { explicit Vector(int num_slots); void Insert(int value); };   Other signs an interface is hard to use:\n Initialize / Deitialize functions. Allowing partially created objects. Parameters that can have invalid values.  Sometimes it\u0026rsquo;s not practical to have a foolproof interface. In those cases rely on static analysis or documentation.\nOnly Verify Relevant Method Arguments June 26, 2018 - original post\nTests become fragile when they expect exact values on irrelevant arguments.\nTEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fake_clock_.SetTime(kNewYearsDay); fake_user_.SetName(\u0026quot;Fake User\u0026quot;); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(\u0026quot;Hi Fake User! Happy New Year!\u0026quot;, TitleBar(\u0026quot;2018-01-01\u0026quot;), PromptStyle::kNormal)); user_greeter_.DisplayGreeting(); }    Only verify one behavior per test. Only verify arguments that affect the correctness of the specific behavior being tested.  TEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) { fake_clock_.SetTime(kNewYearsDay); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(\u0026quot;Happy New Year!\u0026quot;), _, _)); user_greeter_.DisplayGreeting(); } TEST_F(DisplayGreetingTest, RenderUserName) { fake_user_.SetName(\u0026quot;Fake User\u0026quot;); EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(\u0026quot;Fake User\u0026quot;), _, _)); user_greeter_.DisplayGreeting(); }   Keep Tests Focused June 11, 2018 - original post\nTesting too many scenarios at once can make it difficult to understand test and reason about the failure.\nTEST_F(BankAccountTest, WithdrawFromAccount) { Transaction transaction = account_.Deposit(Usd(5)); clock_.AdvanceTime(kMinTimeToSettle); account_.Settle(transaction); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); EXPECT_THAT(account_.Withdraw(USd(1)), IsRejected()); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(1)), IsOk()); }   Break up each scenario into its own test.\nTEST_F(BankAccountTest, CanWithdrawWithinBalance) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk()); } TEST_F(BankAccountTest, CannotOverdraw) { DepositAndSettle(Usd(5)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsRejected()); } TEST_F(BankAccountTest, CanOverdrawUpToOverdraftLimit) { DepositAndSettle(Usd(5)); account_.SetOverdraftLimit(Usd(1)); EXPECT_THAT(account_.Withdraw(Usd(6)), IsOk()); }   Notice how each test only verifies the output of one call per test.\nUnderstanding Code in Review May 1, 2018 - original post\nIf you find yourself reviewing code that is difficult to understand, don\u0026rsquo;t waste time reviewing it.\nbool IsOkay(int n) { bool f = false; for (int i = 2; i \u0026lt;= n; ++i) { if (n % i == 0) f = true; } return !f; }   Ask for it to be clarified.\nbool IsPrime(int n) { for (int divisor = 2; divisor \u0026lt;= n / 2; ++divisor) { if (n % divisor == 0) return false; } return true; }   Clarifying code often results in noticing improvements.\nCleanly Create Test Data February 20, 2018 - original post\nHelper methods make it easier to create test data, but they don\u0026rsquo;t age well.\n// Starts simple Company company = NewCompany(kPublic); // But soon acquires more parameters Company small = NewCompany(2, 2, nullptr, kPublic); Company privately_owned = NewCompany(0, 0, nullptr, kPrivate); Company bankrupt = NewCompany(0 , 0, kPastDate, kPublic); // Or more methods Company small = NewCompanyWithEmployeesAndBoardMembers(2, 2, kPublic); Company privately_owned = NewCompanyWithType(kPrivate); Company bankrupt = NewCompanyWithBankruptcyDate(kPastDate, kPublic);   Try the builder pattern.\nCompany small = Company::Builder{}.SetEmployees(2).SetBoardMembers(2).Build(); Company privately_owned = Company::Builder{}.SetType(kPrivate).Build(); Company bankrupt = Company::Builder{}.SetBankruptcyDate(kPastDate).Build(); Company default_company = Company::Builder{}.Build(); class Company::Builder { public: Builder\u0026amp; SetEmployees(int n) { employees_ = n; return *this; } Builder\u0026amp; SetBoardMembers(int n) { board_members_ = n; return *this; } Builder\u0026amp; SetBankruptcyDate(BankruptcyDate d) { date_ = d; return *this; } Builder\u0026amp; SetType(Type t) { type_ = t; return *this; } Company Build() const { return Company(employees_, board_members_, date_, type_); } private: int employees_ = 0; int board_members_ = 0; BankruptcyDate date_ = kBeforeDate; Type type_ = kPublic; };   Only Expect State-Changing Method Calls December 11, 2017 - original post\nExpecting calls to methods that don\u0026rsquo;t change state can make a test brittle, less readable, and provide a false sense of security.\nTEST(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_user_service_, IsUserActive(kUser); EXPECT_CALL(mock_permission_db_, GetPermission(kUser); EXPECT_CALL(mock_permission_db_, IsValidPermission(kReadAccess); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }   It is fine, however, to use non-state-changing methods for simulating test conditions.\nON_CALL(mock_user_service_, IsUserActive(kUser)).WillByDefault(Return(false));   With unnecessary EXPECT_CALLs removed, the test becomes:\nTest(UserAuthorizer, AddPermissionToDatabase) { UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_); EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess); user_authorizer.GrantPermission(kUser, kReadAccess); }   Obsessed With Primitives? November 14, 2017 - original post\nCode that relies too heavily on primitive types instead of custom abstractions can be hard to understand and maintain.\nstd::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; polygon = { std::make_pair(0, 0), std::make_pair(0, 4), std::make_pair(4, 0) }; std::pair\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::pair\u0026lt;int, int\u0026gt;\u0026gt; bounding_box = GetBoundingBox(polygon); int area = (bounding_box.second.first - bounding_box.first.first) * (bounding_box.second.second - bounding_box.first.second);   Make higher-level abstractions.\nPolygon polygon = RightTriangle(4, 4); int area = polygon.GetBoundingBox().GetArea();   This advice doesn\u0026rsquo;t just apply to primitives and The STL. It\u0026rsquo;s possible for any type to be too primitive for the job.\nPolygon polygon = IsoscelesRightTriangle(4); int area = polygon.GetBoundingBox().GetArea();   IdentifierNamingPostForWorldWideWebBlog October 23, 2017 - original post\nNames should be clear and precise.\nDon\u0026rsquo;t mention the type in the variable name. It\u0026rsquo;s OK for the name and the type match.\nstd::string name_string; std::list\u0026lt;std::time_t\u0026gt; holiday_date_list;   std::string name; std::list\u0026lt;std::time_t\u0026gt; holidays; Payments payments;   Don\u0026rsquo;t use overly specific names. Get more specific if there is a need for disambiguation.\nMonster final_battle_most_dangerous_boss_monster; Payments non_typical_monthly_payments;   Monster boss; Payments payments;   Do not repeat context.\nclass AnnualHolidaySale { bool PromoteHolidaySale(); int annual_sale_rebate_; };   class AnnualHolidaySale { bool Promote(); int rebate_; }   To Comment or Not to Comment July 17, 2017 - original post\nComments are not always helpful.\n// Subtract discount from final price. final_price = (num_items * item_price) - std::min(5, num_items) * item_price * 0.1; // Filter offensive words. for (std::string word : words) { ... } int width = ...; // Width in pixels. // Safe since height is always \u0026gt; 0. return width / height;   It\u0026rsquo;s often better to make your code self-explanatory.\nprice = num_items * item_price; discount = std::min(5, num_items) * item_price * 0.1; final_price = price - discount; FilterOffensiveWords(words); Pixels width = ...; CheckArgument(height \u0026gt; 0); return width / height;   Avoid using comments to explain what code does. Use comments to explain why code does something.\nToo Many Comments on Your Code Reviews? June 19, 2017 - original post\nBefore you send out the code review:\n Review your own code first. Discuss with colleagues. Make bite-sized reviews. Add comments to the code if necessary.  When addressing code review comments:\n Review your code after addressing non-trivial comments. Understand the reviews thought process. Answer questions in the code.  Reduce Nesting, Reduce Complexity June 15, 2017 - original post\nDeeply nested code is error-prone and hurts readability.\nResponse response = server.Call(request); if (response.GetStatus() == Status::kOk) { if (!IsAuthorized(response.GetUser())) { if (response.GetEnc() == \u0026quot;utf-8\u0026quot;) { std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (!rows.empty()) { avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg; } else { throw EmptyException(); } else { throw AuthException('unauthorized'); } } else { throw ValueException('wrong encoding'); } } else { throw RpcException(response.GetStatus()); }   The code above could be refactored to use guard clauses.\nResponse response = server.Call(request); if (response.GetStatus() != Status::kOk) { throw RpcException(response.GetStatus()); } if (!IsAuthorized(response.GetUser())) { throw ValueException('wrong encoding'); } if (response.GetEnc() != \u0026quot;utf-8\u0026quot;) { throw AuthException('unauthorized'); } std::vector\u0026lt;Row\u0026gt; rows = response.GetRows(); if (rows.empty()) { throw EmptyException(); } avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size(); return avg;   Can you spot the bug now?\nKeep Cause and Effect Clear January 31, 2017 - original post\nIt\u0026rsquo;s difficult to reason about a test when the cause is hidden far away from the effect.\nclass TallyTest : public ::testing::Test { protected: void SetUp() override { tally_.Increment(\u0026quot;key1\u0026quot;, 8); tally_.Increment(\u0026quot;key2\u0026quot;, 100); tally_.Increment(\u0026quot;key1\u0026quot;, 0); tally_.Increment(\u0026quot;key1\u0026quot;, 1); } Tally tally_; } // 200 lines of code TEST_F(TallyTest, IncrementExistingKey) { EXPECT_EQ(9, tally_.Get(\u0026quot;key1\u0026quot;)); }   Write tests where the effects immediately follow the causes.\nclass TallyTest : public ::testing::Test { protected: Tally tally_; } TEST_F(TallyTest, NewKey) { tally_.Increment(\u0026quot;key\u0026quot;, 100); EXPECT_EQ(100, tally_.Get(\u0026quot;key\u0026quot;)); } TEST_F(TallyTest, ExistingKey) { tally_.Increment(\u0026quot;key\u0026quot;, 8); tally_.Increment(\u0026quot;key\u0026quot;, 1); EXPECT_EQ(9, tally_.Get(\u0026quot;key\u0026quot;)); } TEST_F(TallyTest, IncrementByZeroDoesNothing) { tally_.Increment(\u0026quot;key\u0026quot;, 8); tally_.Increment(\u0026quot;key\u0026quot;, 0); EXPECT_EQ(8, tally_.Get(\u0026quot;key\u0026quot;)); }   It may require a bit more code, but it\u0026rsquo;s easier to read and maintain.\nWhat Makes a Good End-to-End Test? September, 2016 - original post\nEnd-to-end tests give confidence about the health of the system when it is in a near production state, but they tend to be more flaky and expensive to maintain.\nTo be cost effective, end-to-end tests should focus on aspects of the system that cannot be evaluated by smaller tests. Minor and/or frequently changing details like error messages or visual layouts should not effect the test.\nChange-Detector Tests Considered Harmful January 27, 2015 - original post\nTests that break in response to any change to production code without verifying correct behavior only add to maintenance costs without catching defects.\nvoid Processor::Process(Work w) { first_part_.Process(w); second_part_.Process(w); } TEST(ProcessorTest, ProcessWork) { MockFirstPart part1; MockSecondPart part2; Processor p(part1, part2); Work w; EXPECT_CALL(part1, Process(w)); EXPECT_CALL(part2, Process(w)); p.Process(w); }   Tests like these should either be re-written or deleted.\nPrefer Testing Public APIs Over Implementation-Detail Classes January 14, 2015 - original post\nPublic APIs can be called by many users. Implementation details are only called by public APIs. If the public APIs are well tested, as they should be, then the implementation details will get tested by association.\nHeavy testing against implementation details can cause a couple problems:\n Unlike public APIs, implementation details are vulnerable to refactoring. Tests for implementation details can fail even though the behavior from the public API is fine. Testing implementation details can give false confidence. Even if an implementation detail is well tested, that doesn\u0026rsquo;t mean the pubic API behaves properly.  Writing Descriptive Test Names October 16, 2014 - original post\nVague test names make it hard to keep track of what is tested.\nTEST_F(IsUserLockedOutTest, InvalidLogin) { authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_FALSE(authenticator_.IsUserLockedOut(username_)); authenticator_.Authenticate(username_, password_); EXPECT_TRUE(authenticator_.IsUserLockedOut(username_)); }   Descriptive test names make it easy to tell what behavior is broken without looking at code. Also, the length of a good test name helps indicate when a test needs to be split apart.\nTEST_F(IsUserLockedOutTest, ShouldLockOutUserAfterThreeInvalidLoginAttempts) { // ... }   A test\u0026rsquo;s name should be all you need to know to understand the behavior being tested. Make sure the name contains both the scenario being tested and the expected outcome.\nDon\u0026rsquo;t Put Logic in Tests July 31, 2014 - original post\nTests should be simple by stating I/O directly rather than computing them.\nTEST(NavigatorTest, ShouldNavigateToPhotosPage) { const std::string baseUrl = \u0026quot;http://plus.google.com/\u0026quot;; Navigator nav(baseUrl); nav.GoToPhotosPage(); EXPECT_EQ(baseUrl + \u0026quot;/u/0/photos\u0026quot;, nav.GetCurrentUrl()); }   Even a simple string concatenation can lead to bugs.\nTEST(NavigatorTest, ShouldNavigateToPhotosPage) { Navigator nav(\u0026quot;http://plug.google.com/\u0026quot;); nav.GoToPhotosPage(); EXPECT_EQ(\u0026quot;http://plus.google.com//u/0/photos\u0026quot;, nav.GetCurrentUrl()); }   If a test requires logic, move that logic out of the test body into utilities and helper functions and write tests for them too.\nRisk-Driven Testing May 30, 2014 - original post\nBlindly writing tests can lead to a false sense of security or wasted effort. Before writing tests, think about testing. Small tests are cheap, larger tests protect core use-cases and integration. Manual testing can sometimes be the cheapest, most effective option.\nEffective Testing May 7, 2014 - original post\nTo be effective, a test maximizes three important qualities:\n Fidelity - Sensitive to defects in the code under test. Resilience - Fails only when a breaking change is made to the code under test. Precision - Upon failure reports exactly where the defect lies.  Test Behaviors, Not Methods A single method can exhibit many behaviors. Likewise, a single behavior can span multiple methods.\nIt can be harmful to think that tests and public methods should have a 1:1 relationship.\nTEST_F(TransactionProcessorTest, ProcessTransaction) { User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2)); transaction_processor_.ProcessTransaction(user, Transaction(\u0026quot;Pile of Beanie Babies\u0026quot;, Dollars(3))); EXPECT_THAT(ui_.GetText(), HasSubstr(\u0026quot;You bought a Pile of Beanie Babies\u0026quot;)); EXPECT_EQ(user.GetEmails().size(), 1); EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), \u0026quot;Your balance is low\u0026quot;); }   Each test should verify one behavior. Each method may take several tests to verify.\nTEST_F(TransactionProcessorTest, ShouldDisplayNotification) { transaction_processor_.ProcessTransaction(User(), Transaction(\u0026quot;Pile of Beanie Babies\u0026quot;)); EXPECT_THAT(ui_.GetText(), HasSubstr(\u0026quot;You bought a Pile of Beanie Babies\u0026quot;)); } TEST_F(TransactionProcessorTest, ShouldSendEmailWhenBalanceIsLow) { User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2)); transaction_processor_.ProcessTransaction(user, Transaction(Dollars(3))); EXPECT_EQ(user.GetEmails().size(), 1); EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), \u0026quot;Your balance is low\u0026quot;); }   What Makes a Good Test? Tests provide more than verification. They also serve as documentation.\nAs a source of documentation, test should not be distracting or hide information.\nTEST(CalculatorTest, ShouldPerformAddition) { Calculator calculator(RoundingStrategy(), \u0026quot;unused\u0026quot;, kEnableCosinFeature, 0.01, kCalculusEngine, false); int result = calculator.DoComputation(MakeTestComputation()); EXPECT_EQ(result, 5); }   TEST_(CalculatorTest, ShouldPerformAddition) { const int result = calculator_.DoComputation(MakeAdditionComputation(2, 3)); EXPECT_EQ(result, 5); }   Test Behavior, Not Implementation August 5, 2013 - original post\nExcept where explicitly intended, tests should work independent of the implementation details being tested.\nclass Calculator { public: int Add(int a, int b) { return a + b; } }; class Calculator { public: int Add(int a, int b) { Adder adder = adder_factory_.CreateAdder(); ReturnValue return_value = adder.Compute(Number(a), Number(b)); return return_value.ConvertToInteger(); } private: AdderFactory adder_factory_; }; TEST_F(CalculatorTest, ShouldAddIntegers) { EXPECT_EQ(3, calculator_.Add(2, 1)); EXPECT_EQ(2, calculator_.Add(2, 0)); EXPECT_EQ(1, calculator_.Add(2, -1)); }  Know Your Test Doubles July 18, 2013 - original post\nA test double is an object that can stand in for a real object in test. The most common types of test doubles are:\n Stub - Returns a specific values to promote a specific state.  AccessManager access_manager(kStubAuthenticationService); ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(false)); EXPECT_FALSE(access_manager.UserHasAccess(kUserId)); ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(true)); EXPECT_TRUE(access_manager.UserHasAccess(kUserId));   Mock - Sets expectations about how other objects should interact with it.  AccessManager access_manager(mockAuthenticationService); EXPECT_CALL(mockAuthenticationService, IsAuthenticated(kUserId)); access_manager.UserHasAccess(kUserId);   Fake - A lightweight implementation when the real implementation is unsuitable for test.  FakeAuthenticationService fake_authentication_service; AccessManager access_manager(fake_authentication_service); EXPECT_FALSE(access_manager.UserHasAccess(kUserId)); fake_authentication_service.AddAuthenticatedUser(kUser); EXPECT_TRUE(access_manager.UserHasAccess(kUserId));  Fake Your Way To Better Tests June 28, 2013 - original post\nSuppose you would like to test your blog platform API, but you don\u0026rsquo;t want your tests talking to a remote server.\nvoid DeletePostsWithTag(const Tag\u0026amp; tag) { for (const Post post : blog_service_-\u0026gt;GetAllPosts()) { if (post.HasTag(tag)) { blog_service_-\u0026gt;DeletePost(post.GetId()); } } }  A fake is a lightweight implementation of an API that behaves like the real implementation, but isn\u0026rsquo;t suitable for production.\nclass FakeBlogService : public BlogService { public: void AddPost(const Post\u0026amp; post) { posts.insert(post); } void DeletePost(const int id) { for (auto\u0026amp; post : posts) { if (post.GetId() == id) { posts.erase(post); return; } } } std::set\u0026lt;Post\u0026gt; GetAllPosts() const { return posts; } private: std::set\u0026lt;Post\u0026gt; posts; };  Fakes should be created and maintained by the person or team that owns the real implementation.\nFakes should have their own tests to make sure they behave like the real implementation.\nDon\u0026rsquo;t Overuse Mocks May 28, 2013 - original post\nMocks are powerful, but easy to abuse.\nTEST_F(PaymentProcessorTest, ShouldChargeCreditCard) { PaymentProcessor payment_processor(mock_credit_card_server_); InSequence s; EXPECT_CALL(mock_credit_card_server_, IsServerAvailable()).WillOnce(Return(true)); EXPECT_CALL(mock_credit_card_server_, BeginTransaction()).WillOnce(Return(mock_transaction_manager_)); EXPECT_CALL(mock_transaction_manager_, GetTransaction()).WillOnce(Return(transaction_)); EXPECT_CALL(mock_credit_card_server_, Pay(transaction_, credit_card_, 500)).WillOnce(Return(mock_payment_)); EXPECT_CALL(mock_payment_, IsOverMaxBalance()).WillOnce(Return(false)); payment_processor.ProcessPayment(credit_card_, Dollars(500)); }   Overusing mocks makes tests harder to understand, maintain, and provides less insurance that your code is working properly.\nIf you don\u0026rsquo;t need a mock, don\u0026rsquo;t use one. Understanding when to use a mock comes from understanding what you want to test.\nTEST_F(PaymentProcessorTest, ShouldChargeCreditCard) { PaymentProcessor payment_processor(credit_card_server_); payment_processor.ProcessPayment(credit_card_, Dollars(500)); EXPECT_EQ(credit_card_server_.GetMostRecentCharge(credit_card_), 500); }   Testing State vs. Testing Interactions March 22, 2013 - original post\n Testing State - Verifying the code under test returns the correct results.  TEST(NumberSorterTest, ShouldSortIntegers) { NumberSorter number_sorter({quicksort, bubblesort}); std::vector\u0026lt;int\u0026gt; numbers = {3, 1, 2}; EXPECT_EQ({1, 2, 3}, number_sorter.SortNumbers(numbers)); }   Testing Interaction - Verifying the code under test calls methods correctly.  TEST(NumberSorterTest, ShouldUseQuicksort) { NumberSorter number_sorter({mock_quicksort, mock_bubblesort}); std::vector\u0026lt;int\u0026gt; numbers = {3, 1, 2}; EXPECT_CALL(mock_quicksort, Sort(numbers); number_sorter.SortNumbers(numbers); }  Most of the time you want to test state. Occasionally interactions need to be tested when the number of calls or order of calls matter.\nData Driven Traps! September 4, 2008 - original post\nData driven tests are efficient, but easy to abuse.\nstruct TestData { const std::string word; const bool is_word; }; const std::vector\u0026lt;TestData\u0026gt; test_data = { {\u0026quot;milk\u0026quot;, true}, {\u0026quot;centre\u0026quot;, false}, {\u0026quot;jklm\u0026quot;, false}, }; TEST(IsWordTest, TestEverything) { for (const auto\u0026amp; entry : test_data) { EXPECT_EQ(IsWord(entry.word), entry.is_word); } }   Data-driven tests make debugging and understanding failures, let alone false positives, more difficult.\nAs the code grows in complexity, data tends to grow even faster. It quickly becomes impossible to discern what behavior each piece of data is meant to test.\nconst std::vector\u0026lt;Locale\u0026gt; locales = { Word::US, Word::UK, Word::France, ... }; struct TestData { std::string word; bool[kNumLocales] is_word; }; const std::vector\u0026lt;TestData\u0026gt; test_data = { {\u0026quot;milk\u0026quot;, {true, true, false, ...}, {\u0026quot;centre\u0026quot;, {false, true, true, ...}}, {\u0026quot;jklm\u0026quot;, {false, false, false, ...}}, }; TEST(IsWordTest, TestEverything) { for (const auto\u0026amp; entry : test_data) { for (const auto* locale: locales) { EXPECT_EQ(IsWord(entry.word, locale), entry.is_word); } } }   Instead, think critically about what behaviors are worth testing.\nTEST(IsWordTest, ShouldExistInMultipleLocales) { EXPECT_TRUE(IsWord(\u0026quot;milk\u0026quot;, Word::US)); EXPECT_TRUE(IsWord(\u0026quot;milk\u0026quot;, Word::UK)); EXPECT_FALSE(IsWord(\u0026quot;milk\u0026quot;, Word::France)); } TEST(IsWordTest, ShouldNotExist) { // \u0026quot;jklm\u0026quot; test not repeated as it uses the same code path EXPECT_FALSE(IsWord(\u0026quot;jklm\u0026quot;, Word::US)); }   Sleeping != Synchronization August 21, 2008 - original post\nAny code that sleeps should be considered taboo. In test, sleep should be banned.\nclass Employee { public: void DrinkCoffee() { caffeinated_ = true; } bool IsCaffeinated() { return caffeinated_; } void DemandCoffee(Intern\u0026amp; intern) { std::thread t(\u0026amp;Intern::MakeCoffee, \u0026amp;intern, std::bind(\u0026amp;Employee::DrinkCoffee, this)); t.detach(); } private: bool caffeinated_ = false; }; TEST(EmployeeTest, ShouldBeCaffeinatedWithinAMinute) { Employee e; Intern i; e.DemandCoffee(i); EXPECT_FALSE(e.IsCaffeinated()); std::this_thread::sleep_for(60s); EXPECT_TRUE(e.IsCaffeinated()); }   Code that sleeps can be improved by waiting on a std::future or a std::condition_variable. If your waiting on a non-trivial operation, use a fake.\nclass CoffeeMaker { public: virtual void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) = 0; }; class FakeIntern : public CoffeeMaker { public: void MakeCoffee(const std::function\u0026lt;void()\u0026gt; callback) { callback(); } }; class Employee { public: void DrinkCoffee() { caffeinated_ = true; } bool IsCaffeinated() { return caffeinated_; } void DemandCoffee(CoffeeMaker\u0026amp; cm) { std::future\u0026lt;void\u0026gt; f = std::async(\u0026amp;CoffeeMaker::MakeCoffee, \u0026amp;cm, std::bind(\u0026amp;Employee::DrinkCoffee, this)); f.wait_for(60s); } private: bool caffeinated_ = false; }; TEST(EmployeeTest, ShouldBeCaffeinatedWithinAMinute) { Employee e; FakeIntern i; EXPECT_FALSE(e.IsCaffeinated()); e.DemandCoffee(i); EXPECT_TRUE(e.IsCaffeinated()); }   Defeat \u0026ldquo;Static Cling\u0026rdquo; June 26 - original post\nStatic functions, like this singleton GetInstance method, are a sign of tight coupling.\nclass MyObject { public: int DoSomething(int id) { return TheirEntity::GetInstance().GetSomething(); } };  There is a way around this using the Repository Pattern.\nclass TheirEntityStaticRepository : public TheirEntityRepository { public: TheirEntity\u0026amp; GetInstance() { return TheirEntity::GetInstance(); } }; class MyObject { public: explicit MyObject(std::unique_ptr\u0026lt;TheirEntityRepository\u0026gt; repository) : repository_(std::move(repository)) {} int DoSomething(int id) { return repository_-\u0026gt;GetInstance().GetSomething(); } private: std::unique_ptr\u0026lt;TheirEntityRepository\u0026gt; repository_; };  All thats left is to derive a TheirEntityRepository suitable for your testing needs.\nTestable Contracts Make Exceptional Neighbors May 28, 2008 - original post\nModify external visible state only after completing all operations which could possibly fail.\nbool SomeCollection::GetObjects(std::vector\u0026lt;Object\u0026gt;\u0026amp; objects) const { objects.clear(); for (const auto\u0026amp; object : collection_) { if (object.IsFubarred()) return false; objects.push_back(object); } return true; }   This can be done using the swap trick.\nbool SomeCollection::GetObjects(std::vector\u0026lt;Object\u0026gt;\u0026amp; objects) const { std::vector\u0026lt;Object\u0026gt; known_good_objects; for (const auto\u0026amp; object : collection_) { if (object.IsFubarred()) return false; known_good_objects.push_back(object); } objects.swap(known_good_objects); return true; }   Now, the caller has good objects on success, or unchanged objects on failure.\nUnderstanding Your Coverage Data March 6, 2008 - original post\nHigh test coverage is necessary but not sufficient.\nUse your test coverage results to look for unexpected coverage patterns, which usually indicate bugs, and add test cases to address them.\n"
}]
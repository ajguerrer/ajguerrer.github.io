<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="theme-color" content="#85ad85">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="translucent">
    <link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />
    <title>Testing on the Toilet :: Notebook</title>

    
    <link href="/css/nucleus.css?1564022436" rel="stylesheet">
    <link href="/css/fontawesome-all.min.css?1564022436" rel="stylesheet">
    <link href="/css/hybrid.css?1564022436" rel="stylesheet">
    <link href="/css/featherlight.min.css?1564022436" rel="stylesheet">
    <link href="/css/perfect-scrollbar.min.css?1564022436" rel="stylesheet">
    <link href="/css/auto-complete.css?1564022436" rel="stylesheet">
    <link href="/css/atom-one-dark-reasonable.css?1564022436" rel="stylesheet">
    <link href="/css/theme.css?1564022436" rel="stylesheet">
    <link href="/css/hugo-theme.css?1564022436" rel="stylesheet">
    
      <link href="/css/theme-gruvbox.css?1564022436" rel="stylesheet">
    

    <script src="/js/jquery-3.3.1.min.js?1564022436"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
    </style>
    <link href="/css/gruvbox-dark.css" rel="stylesheet"/>
  </head>
  <body class="" data-url="/google-testing-blog/tott/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <div class="logo">
  <svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 90.000000 183.000000"
    preserveAspectRatio="xMidYMid meet">
    <g transform="translate(0.000000,183.000000) scale(0.100000,-0.100000)" stroke="none">
      <path d="M437 1690 c-4 -30 -7 -131 -8 -225 -2 -224 -2 -224 -62 -242 -67 -19
    -147 -97 -147 -141 0 -18 2 -32 4 -32 2 0 15 17 29 38 27 41 104 96 150 107
    l28 7 -3 -107 -3 -108 -30 -11 c-54 -19 -106 -57 -103 -75 2 -9 35 -32 74 -51
    l72 -35 7 -68 c8 -84 17 -80 19 8 l1 66 58 24 c32 13 67 31 78 41 17 15 18 19
    4 34 -8 9 -42 29 -75 45 l-60 29 0 101 c0 56 3 104 6 107 7 8 100 -29 134 -53
    14 -10 41 -40 60 -68 31 -45 50 -62 50 -46 0 17 -43 85 -72 114 -33 34 -119
    81 -149 81 -19 0 -24 43 -35 309 -8 182 -17 235 -27 151z m-11 -806 l-7 -33
    -40 18 c-68 31 -68 38 -8 66 l54 25 3 -21 c2 -12 1 -36 -2 -55z m101 50 c24
    -9 43 -21 43 -25 0 -12 -40 -36 -72 -44 -27 -7 -28 -6 -28 39 0 25 3 46 7 46
    4 0 27 -7 50 -16z" />
      <path d="M92 893 c14 -133 101 -250 231 -311 37 -18 74 -32 81 -32 8 0 17 -4
20 -8 3 -5 6 -109 7 -231 0 -123 5 -219 9 -214 19 20 30 125 30 278 l0 165 28
6 c75 17 98 25 133 50 57 39 108 107 139 183 32 77 49 157 31 147 -6 -4 -11
-12 -11 -17 0 -6 -16 -49 -36 -95 -31 -72 -46 -93 -98 -138 -69 -60 -120 -81
-176 -72 -22 3 -41 2 -45 -4 -15 -25 -86 1 -173 63 -51 37 -127 151 -148 224
-9 29 -18 53 -21 53 -3 0 -3 -21 -1 -47z" />
    </g>
  </svg>
  <p>Notebook</p>
</div>
    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="/js/lunr.min.js?1564022436"></script>
<script type="text/javascript" src="/js/auto-complete.js?1564022436"></script>
<script type="text/javascript">
    
        var baseurl = "https:\/\/ajguerrer.github.io\/";
    
</script>
<script type="text/javascript" src="/js/search.js?1564022436"></script>

    
  </div>

    <div class="highlightable">
    <ul class="topics">

        
          
          


 
  
    
    <li data-nav-id="/google-testing-blog/" title="Google Testing Blog" class="dd-item 
        parent
        
        
        ">
      <a href="/google-testing-blog/">
          Google Testing Blog
          
      </a>
      
      
        <ul>
          
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/google-testing-blog/general/" title="General Notes" class="dd-item ">
        <a href="/google-testing-blog/general/">
        General Notes
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/google-testing-blog/testable_code/" title="Guide to Writing Testable Code" class="dd-item ">
        <a href="/google-testing-blog/testable_code/">
        Guide to Writing Testable Code
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/google-testing-blog/whittaker/" title="James Whittaker" class="dd-item ">
        <a href="/google-testing-blog/whittaker/">
        James Whittaker
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/google-testing-blog/tott/" title="Testing on the Toilet" class="dd-item active">
        <a href="/google-testing-blog/tott/">
        Testing on the Toilet
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
         
    </ul>

    
    

    
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fas fa-heart"></i></a> from <a href="https://getgrav.org">Grav</a> and <a href="https://gohugo.io/">Hugo</a></p>

    </section>
  </div>
</nav>





        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
          
          
            
            
          
          
            
            
          
          
            <a href='/'>Notebook</a> > <a href='/google-testing-blog/'>Google Testing Blog</a> > Testing on the Toilet
          
         
          
         
          
        
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#exercise-service-call-contracts-in-tests">Exercise Service Call Contracts in Tests</a></li>
<li><a href="#make-interfaces-hard-to-misuse">Make Interfaces Hard to Misuse</a></li>
<li><a href="#only-verify-relevant-method-arguments">Only Verify Relevant Method Arguments</a></li>
<li><a href="#keep-tests-focused">Keep Tests Focused</a></li>
<li><a href="#understanding-code-in-review">Understanding Code in Review</a></li>
<li><a href="#cleanly-create-test-data">Cleanly Create Test Data</a></li>
<li><a href="#only-expect-state-changing-method-calls">Only Expect State-Changing Method Calls</a></li>
<li><a href="#obsessed-with-primitives">Obsessed With Primitives?</a></li>
<li><a href="#identifiernamingpostforworldwidewebblog">IdentifierNamingPostForWorldWideWebBlog</a></li>
<li><a href="#to-comment-or-not-to-comment">To Comment or Not to Comment</a></li>
<li><a href="#too-many-comments-on-your-code-reviews">Too Many Comments on Your Code Reviews?</a></li>
<li><a href="#reduce-nesting-reduce-complexity">Reduce Nesting, Reduce Complexity</a></li>
<li><a href="#keep-cause-and-effect-clear">Keep Cause and Effect Clear</a></li>
<li><a href="#what-makes-a-good-end-to-end-test">What Makes a Good End-to-End Test?</a></li>
<li><a href="#change-detector-tests-considered-harmful">Change-Detector Tests Considered Harmful</a></li>
<li><a href="#prefer-testing-public-apis-over-implementation-detail-classes">Prefer Testing Public APIs Over Implementation-Detail Classes</a></li>
<li><a href="#writing-descriptive-test-names">Writing Descriptive Test Names</a></li>
<li><a href="#don-t-put-logic-in-tests">Don&rsquo;t Put Logic in Tests</a></li>
<li><a href="#risk-driven-testing">Risk-Driven Testing</a></li>
<li><a href="#effective-testing">Effective Testing</a></li>
<li><a href="#test-behaviors-not-methods">Test Behaviors, Not Methods</a></li>
<li><a href="#what-makes-a-good-test">What Makes a Good Test?</a></li>
<li><a href="#test-behavior-not-implementation">Test Behavior, Not Implementation</a></li>
<li><a href="#know-your-test-doubles">Know Your Test Doubles</a></li>
<li><a href="#fake-your-way-to-better-tests">Fake Your Way To Better Tests</a></li>
<li><a href="#don-t-overuse-mocks">Don&rsquo;t Overuse Mocks</a></li>
<li><a href="#testing-state-vs-testing-interactions">Testing State vs. Testing Interactions</a></li>
<li><a href="#code-coverage-goal-80-and-no-less">Code coverage goal: 80% and no less!</a></li>
<li><a href="#data-driven-traps">Data Driven Traps!</a></li>
<li><a href="#sleeping-synchronization">Sleeping != Synchronization</a></li>
<li><a href="#defeat-static-cling">Defeat &ldquo;Static Cling&rdquo;</a></li>
<li><a href="#testable-contracts-make-exceptional-neighbors">Testable Contracts Make Exceptional Neighbors</a></li>
<li><a href="#understanding-your-coverage-data">Understanding Your Coverage Data</a></li>
<li><a href="#too-many-tests">Too Many Tests</a></li>
<li><a href="#avoiding-friend-twister-in-c">Avoiding Friend Twister in C++</a></li>
<li><a href="#refactoring-tests-in-the-red">Refactoring Tests in the Red</a></li>
</ul></li>
</ul>
</nav>
    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
              
              Testing on the Toilet
            </h1>
          

        





<p>This page contains portable (potable?) bits of testing best-practices that will keep you riveted to
your seat.</p>

<h2 id="exercise-service-call-contracts-in-tests">Exercise Service Call Contracts in Tests</h2>

<p><em>November 27, 2018</em> -
<a href="https://testing.googleblog.com/2018/11/testing-on-toilet-exercise-service-call.html">original post</a></p>

<p>If the code under test relies on the contract of a service, prefer exercising the service call
instead of mocking it out. Some service owners provide a fake. Otherwise, use a hermetic server.</p>

<h2 id="make-interfaces-hard-to-misuse">Make Interfaces Hard to Misuse</h2>

<p><em>July 25, 2018</em> -
<a href="https://testing.googleblog.com/2018/07/code-health-make-interfaces-hard-to.html">original post</a></p>

<p>Don&rsquo;t push the responsibility of maintaining invariants on the caller.</p>


<div class="notices warning" ><pre><code class="language-cpp">class Vector {
  explicit Vector(int num_slots);
  int RemainingSlots() const;
  void AddSlots(int num_slots);
  void Insert(int value);
};
</code></pre>
</div>


<p>In the code above, the caller needs to check <code>RemainingSlots</code>, and if <code>0</code>, <code>AddSlots</code> in order for
<code>Insert</code> to work properly.</p>

<p>Instead, <code>Insert</code> could automatically manage slots.</p>


<div class="notices tip" ><pre><code class="language-cpp">class Vector {
  explicit Vector(int num_slots);
  void Insert(int value);
};
</code></pre>
</div>


<p>Other signs an interface is hard to use:</p>

<ul>
<li><code>Initialize</code> / <code>Deitialize</code> functions.</li>
<li>Allowing partially created objects.</li>
<li>Parameters that can have invalid values.</li>
</ul>

<p>Sometimes it&rsquo;s not practical to have a foolproof interface. In those cases rely on static analysis
or documentation.</p>

<h2 id="only-verify-relevant-method-arguments">Only Verify Relevant Method Arguments</h2>

<p><em>June 26, 2018</em> -
<a href="https://testing.googleblog.com/2018/06/testing-on-toilet-only-verify-relevant.html">original post</a></p>

<p>Tests become fragile when they expect exact values on irrelevant arguments.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) {
  fake_clock_.SetTime(kNewYearsDay);
  fake_user_.SetName(&quot;Fake User&quot;);
  EXPECT_CALL(mock_user_prompter_, UpdatePrompt(&quot;Hi Fake User! Happy New Year!&quot;,
                                                TitleBar(&quot;2018-01-01&quot;),
                                                PromptStyle::kNormal));
  user_greeter_.DisplayGreeting();
}
</code></pre>
</div>


<ul>
<li>Only verify one behavior per test.</li>
<li>Only verify arguments that affect the correctness of the specific behavior being tested.</li>
</ul>


<div class="notices tip" ><pre><code class="language-cpp">TEST_F(DisplayGreetingTest, ShowSpecialGreetingOnNewYearsDay) {
  fake_clock_.SetTime(kNewYearsDay);
  EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(&quot;Happy New Year!&quot;), _, _));
  user_greeter_.DisplayGreeting();
}

TEST_F(DisplayGreetingTest, RenderUserName) {
  fake_user_.SetName(&quot;Fake User&quot;);
  EXPECT_CALL(mock_user_prompter_, UpdatePrompt(HasSubstr(&quot;Fake User&quot;), _, _));
  user_greeter_.DisplayGreeting();
}
</code></pre>
</div>


<h2 id="keep-tests-focused">Keep Tests Focused</h2>

<p><em>June 11, 2018</em> -
<a href="https://testing.googleblog.com/2018/06/testing-on-toilet-keep-tests-focused.html">original post</a></p>

<p>Testing too many scenarios at once can make it difficult to understand test and reason about the
failure.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST_F(BankAccountTest, WithdrawFromAccount) {
  Transaction transaction = account_.Deposit(Usd(5));
  clock_.AdvanceTime(kMinTimeToSettle);
  account_.Settle(transaction);

  EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk());
  EXPECT_THAT(account_.Withdraw(USd(1)), IsRejected());
  account_.SetOverdraftLimit(Usd(1));
  EXPECT_THAT(account_.Withdraw(Usd(1)), IsOk());
}
</code></pre>
</div>


<p>Break up each scenario into its own test.</p>


<div class="notices tip" ><pre><code class="language-cpp">TEST_F(BankAccountTest, CanWithdrawWithinBalance) {
  DepositAndSettle(Usd(5));
  EXPECT_THAT(account_.Withdraw(Usd(5)), IsOk());
}

TEST_F(BankAccountTest, CannotOverdraw) {
  DepositAndSettle(Usd(5));
  EXPECT_THAT(account_.Withdraw(Usd(6)), IsRejected());
}

TEST_F(BankAccountTest, CanOverdrawUpToOverdraftLimit) {
  DepositAndSettle(Usd(5));
  account_.SetOverdraftLimit(Usd(1));
  EXPECT_THAT(account_.Withdraw(Usd(6)), IsOk());
}
</code></pre>
</div>


<p>Notice how each test only verifies the output of one call per test.</p>

<h2 id="understanding-code-in-review">Understanding Code in Review</h2>

<p><em>May 1, 2018</em> - <a href="https://testing.googleblog.com/2018/05/code-health-understanding-code-in-review.html">original
post</a></p>

<p>If you find yourself reviewing code that is difficult to understand, don&rsquo;t waste time reviewing it.</p>


<div class="notices warning" ><pre><code class="language-cpp">bool IsOkay(int n) {
  bool f = false;
  for (int i = 2; i &lt;= n; ++i) {
    if (n % i == 0) f = true;
  }
  return !f;
}
</code></pre>
</div>


<p>Ask for it to be clarified.</p>


<div class="notices tip" ><pre><code class="language-cpp">bool IsPrime(int n) {
  for (int divisor = 2; divisor &lt;= n / 2; ++divisor) {
    if (n % divisor == 0) return false;
  }
  return true;
}
</code></pre>
</div>


<p>Clarifying code often results in noticing improvements.</p>

<h2 id="cleanly-create-test-data">Cleanly Create Test Data</h2>

<p><em>February 20, 2018</em> - <a href="https://testing.googleblog.com/2018/02/testing-on-toilet-cleanly-create-test.html">original
post</a></p>

<p>Helper methods make it easier to create test data, but they don&rsquo;t age well.</p>


<div class="notices warning" ><pre><code class="language-cpp">// Starts simple
Company company = NewCompany(kPublic);

// But soon acquires more parameters
Company small = NewCompany(2, 2, nullptr, kPublic);
Company privately_owned = NewCompany(0, 0, nullptr, kPrivate);
Company bankrupt = NewCompany(0 , 0, kPastDate, kPublic);

// Or more methods
Company small = NewCompanyWithEmployeesAndBoardMembers(2, 2, kPublic);
Company privately_owned = NewCompanyWithType(kPrivate);
Company bankrupt = NewCompanyWithBankruptcyDate(kPastDate, kPublic);
</code></pre>
</div>


<p>Try the builder pattern.</p>


<div class="notices tip" ><pre><code class="language-cpp">Company small = Company::Builder{}.SetEmployees(2).SetBoardMembers(2).Build();
Company privately_owned = Company::Builder{}.SetType(kPrivate).Build();
Company bankrupt = Company::Builder{}.SetBankruptcyDate(kPastDate).Build();
Company default_company = Company::Builder{}.Build();

class Company::Builder {
 public:
  Builder&amp; SetEmployees(int n) { employees_ = n; return *this; }
  Builder&amp; SetBoardMembers(int n) { board_members_ = n; return *this; }
  Builder&amp; SetBankruptcyDate(BankruptcyDate d) { date_ = d; return *this; }
  Builder&amp; SetType(Type t) { type_ = t; return *this; }

  Company Build() const { return Company(employees_, board_members_, date_, type_); }

 private:
  int employees_ = 0;
  int board_members_ = 0;
  BankruptcyDate date_ = kBeforeDate;
  Type type_ = kPublic;
};
</code></pre>
</div>


<h2 id="only-expect-state-changing-method-calls">Only Expect State-Changing Method Calls</h2>

<p><em>December 11, 2017</em> - <a href="https://testing.googleblog.com/2017/12/testing-on-toilet-only-verify-state.html">original
post</a></p>

<p>Expecting calls to methods that don&rsquo;t change state can make a test brittle, less readable, and
provide a false sense of security.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST(UserAuthorizer, AddPermissionToDatabase) {
  UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_);

  EXPECT_CALL(mock_user_service_, IsUserActive(kUser);
  EXPECT_CALL(mock_permission_db_, GetPermission(kUser);
  EXPECT_CALL(mock_permission_db_, IsValidPermission(kReadAccess);
  EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess);

  user_authorizer.GrantPermission(kUser, kReadAccess);
}
</code></pre>
</div>


<p>It is fine, however, to use non-state-changing methods for simulating test conditions.</p>


<div class="notices tip" ><pre><code class="language-cpp">ON_CALL(mock_user_service_, IsUserActive(kUser)).WillByDefault(Return(false));
</code></pre>
</div>


<p>With unnecessary <code>EXPECT_CALL</code>s removed, the test becomes:</p>


<div class="notices tip" ><pre><code class="language-cpp">Test(UserAuthorizer, AddPermissionToDatabase) {
  UserAuthorizer user_authorizer(mock_user_service_, mock_permission_db_);

  EXPECT_CALL(mock_permission_db_, AddPermission(kUser, kReadAccess);

  user_authorizer.GrantPermission(kUser, kReadAccess);
}
</code></pre>
</div>


<h2 id="obsessed-with-primitives">Obsessed With Primitives?</h2>

<p><em>November 14, 2017</em> - <a href="https://testing.googleblog.com/2017/11/obsessed-with-primitives.html">original
post</a></p>

<p>Code that relies too heavily on primitive types instead of custom abstractions can be hard to
understand and maintain.</p>


<div class="notices warning" ><pre><code class="language-cpp">std::vector&lt;std::pair&lt;int, int&gt;&gt; polygon = { std::make_pair(0, 0),
                                             std::make_pair(0, 4),
                                             std::make_pair(4, 0) };
std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;&gt; bounding_box = GetBoundingBox(polygon);
int area = (bounding_box.second.first  - bounding_box.first.first) *
           (bounding_box.second.second - bounding_box.first.second);

</code></pre>
</div>


<p>Make higher-level abstractions.</p>


<div class="notices tip" ><pre><code class="language-cpp">Polygon polygon = RightTriangle(4, 4);
int area = polygon.GetBoundingBox().GetArea();
</code></pre>
</div>


<p>This advice doesn&rsquo;t just apply to primitives and The STL. It&rsquo;s possible for any type to be too
primitive for the job.</p>


<div class="notices tip" ><pre><code class="language-cpp">Polygon polygon = IsoscelesRightTriangle(4);
int area = polygon.GetBoundingBox().GetArea();
</code></pre>
</div>


<h2 id="identifiernamingpostforworldwidewebblog">IdentifierNamingPostForWorldWideWebBlog</h2>

<p><em>October 23, 2017</em> - <a href="https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html">original
post</a></p>

<p>Names should be clear and precise.</p>

<p>Don&rsquo;t mention the type in the variable name. It&rsquo;s OK for the name and the type match.</p>


<div class="notices warning" ><pre><code class="language-cpp">std::string name_string;
std::list&lt;std::time_t&gt; holiday_date_list;
</code></pre>
</div>



<div class="notices tip" ><pre><code class="language-cpp">std::string name;
std::list&lt;std::time_t&gt; holidays;
Payments payments;
</code></pre>
</div>


<p>Don&rsquo;t use overly specific names. Get more specific if there is a need for disambiguation.</p>


<div class="notices warning" ><pre><code class="language-cpp">Monster final_battle_most_dangerous_boss_monster;
Payments non_typical_monthly_payments;
</code></pre>
</div>



<div class="notices tip" ><pre><code class="language-cpp">Monster boss;
Payments payments;
</code></pre>
</div>


<p>Do not repeat context.</p>


<div class="notices warning" ><pre><code class="language-cpp">class AnnualHolidaySale {
  bool PromoteHolidaySale();
  int annual_sale_rebate_;
};
</code></pre>
</div>



<div class="notices tip" ><pre><code class="language-cpp">class AnnualHolidaySale {
  bool Promote();
  int rebate_;
}
</code></pre>
</div>


<h2 id="to-comment-or-not-to-comment">To Comment or Not to Comment</h2>

<p><em>July 17, 2017</em> - <a href="https://testing.googleblog.com/2017/07/code-health-to-comment-or-not-to-comment.html">original
post</a></p>

<p>Comments are not always helpful.</p>


<div class="notices warning" ><pre><code class="language-cpp">// Subtract discount from final price.
final_price = (num_items * item_price) -
              std::min(5, num_items) * item_price *  0.1;

// Filter offensive words.
for (std::string word : words) { ... }

int width = ...; // Width in pixels.

// Safe since height is always &gt; 0.
return width / height;
</code></pre>
</div>


<p>It&rsquo;s often better to make your code self-explanatory.</p>


<div class="notices tip" ><pre><code class="language-cpp">price = num_items * item_price;
discount = std::min(5, num_items) * item_price * 0.1;
final_price = price - discount;

FilterOffensiveWords(words);

Pixels width = ...;

CheckArgument(height &gt; 0);
return width / height;
</code></pre>
</div>


<p>Avoid using comments to explain <em>what</em> code does. Use comments to explain <em>why</em> code does something.</p>

<h2 id="too-many-comments-on-your-code-reviews">Too Many Comments on Your Code Reviews?</h2>

<p><em>June 19, 2017</em> - <a href="https://testing.googleblog.com/2017/06/code-health-too-many-comments-on-your.html">original
post</a></p>

<p>Before you send out the code review:</p>

<ul>
<li>Review your own code first.</li>
<li>Discuss with colleagues.</li>
<li>Make bite-sized reviews.</li>
<li>Add comments to the code if necessary.</li>
</ul>

<p>When addressing code review comments:</p>

<ul>
<li>Review your code after addressing non-trivial comments.</li>
<li>Understand the reviews thought process.</li>
<li>Answer questions in the code.</li>
</ul>

<h2 id="reduce-nesting-reduce-complexity">Reduce Nesting, Reduce Complexity</h2>

<p><em>June 15, 2017</em> - <a href="https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html">original
post</a></p>

<p>Deeply nested code is error-prone and hurts readability.</p>


<div class="notices warning" ><pre><code class="language-cpp">Response response = server.Call(request);

if (response.GetStatus() == Status::kOk) {
  if (!IsAuthorized(response.GetUser())) {
    if (response.GetEnc() == &quot;utf-8&quot;) {
      std::vector&lt;Row&gt; rows = response.GetRows();
      if (!rows.empty()) {
        avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size();
        return avg;
      } else {
      throw EmptyException();
    } else {
      throw AuthException('unauthorized');
    }
  } else {
    throw ValueException('wrong encoding');
  }
} else {
  throw RpcException(response.GetStatus());
}
</code></pre>
</div>


<p>The code above could be refactored to use guard clauses.</p>


<div class="notices tip" ><pre><code class="language-cpp">Response response = server.Call(request);

if (response.GetStatus() != Status::kOk) {
  throw RpcException(response.GetStatus());
}

if (!IsAuthorized(response.GetUser())) {
  throw ValueException('wrong encoding');
}

if (response.GetEnc() != &quot;utf-8&quot;) {
  throw AuthException('unauthorized');
}

std::vector&lt;Row&gt; rows = response.GetRows();
if (rows.empty()) {
  throw EmptyException();
}

avg = std::accumulate(rows.begin(), rows.end(), 0, ParseRow) / rows.size();
return avg;
</code></pre>
</div>


<p>Can you spot the bug now?</p>

<h2 id="keep-cause-and-effect-clear">Keep Cause and Effect Clear</h2>

<p><em>January 31, 2017</em> - <a href="https://testing.googleblog.com/2017/01/testing-on-toilet-keep-cause-and-effect.html">original
post</a></p>

<p>It&rsquo;s difficult to reason about a test when the cause is hidden far away from the effect.</p>


<div class="notices warning" ><pre><code class="language-cpp">class TallyTest : public ::testing::Test {
protected:
  void SetUp() override {
    tally_.Increment(&quot;key1&quot;, 8);
    tally_.Increment(&quot;key2&quot;, 100);
    tally_.Increment(&quot;key1&quot;, 0);
    tally_.Increment(&quot;key1&quot;, 1);
  }

  Tally tally_;
}
// 200 lines of code

TEST_F(TallyTest, IncrementExistingKey) {
  EXPECT_EQ(9, tally_.Get(&quot;key1&quot;));
}
</code></pre>
</div>


<p>Write tests where the effects immediately follow the causes.</p>


<div class="notices tip" ><pre><code class="language-cpp">class TallyTest : public ::testing::Test {
protected:
  Tally tally_;
}

TEST_F(TallyTest, NewKey) {
  tally_.Increment(&quot;key&quot;, 100);
  EXPECT_EQ(100, tally_.Get(&quot;key&quot;));
}

TEST_F(TallyTest, ExistingKey) {
  tally_.Increment(&quot;key&quot;, 8);
  tally_.Increment(&quot;key&quot;, 1);
  EXPECT_EQ(9, tally_.Get(&quot;key&quot;));
}

TEST_F(TallyTest, IncrementByZeroDoesNothing) {
  tally_.Increment(&quot;key&quot;, 8);
  tally_.Increment(&quot;key&quot;, 0);
  EXPECT_EQ(8, tally_.Get(&quot;key&quot;));
}
</code></pre>
</div>


<p>It may require a bit more code, but it&rsquo;s easier to read and maintain.</p>

<h2 id="what-makes-a-good-end-to-end-test">What Makes a Good End-to-End Test?</h2>

<p><em>September, 2016</em> - <a href="https://testing.googleblog.com/2016/09/testing-on-toilet-what-makes-good-end.html">original
post</a></p>

<p>End-to-end tests give confidence about the health of the system when it is in a near production
state, but they tend to be more flaky and expensive to maintain.</p>

<p>To be cost effective, end-to-end tests should focus on aspects of the system that cannot be
evaluated by smaller tests. Minor and/or frequently changing details like error messages or visual
layouts should not effect the test.</p>

<h2 id="change-detector-tests-considered-harmful">Change-Detector Tests Considered Harmful</h2>

<p><em>January 27, 2015</em> - <a href="https://testing.googleblog.com/2015/01/testing-on-toilet-change-detector-tests.html">original
post</a></p>

<p>Tests that break in response to any change to production code without verifying correct behavior
only add to maintenance costs without catching defects.</p>


<div class="notices warning" ><pre><code class="language-cpp">void Processor::Process(Work w) {
  first_part_.Process(w);
  second_part_.Process(w);
}

TEST(ProcessorTest, ProcessWork) {
  MockFirstPart part1;
  MockSecondPart part2;
  Processor p(part1, part2);
  Work w;

  EXPECT_CALL(part1, Process(w));
  EXPECT_CALL(part2, Process(w));

  p.Process(w);
}
</code></pre>
</div>


<p>Tests like these should either be re-written or deleted.</p>

<h2 id="prefer-testing-public-apis-over-implementation-detail-classes">Prefer Testing Public APIs Over Implementation-Detail Classes</h2>

<p><em>January 14, 2015</em> - <a href="https://testing.googleblog.com/2015/01/testing-on-toilet-prefer-testing-public.html">original
post</a></p>

<p>Public APIs can be called by many users. Implementation details are only called by public APIs.
If the public APIs are well tested, as they should be, then the implementation details will get
tested by association.</p>

<p>Heavy testing against implementation details can cause a couple problems:</p>

<ul>
<li>Unlike public APIs, implementation details are vulnerable to refactoring. Tests for implementation
details can fail even though the behavior from the public API is fine.</li>
<li>Testing implementation details can give false confidence. Even if an implementation detail is well
tested, that doesn&rsquo;t mean the pubic API behaves properly.</li>
</ul>

<h2 id="writing-descriptive-test-names">Writing Descriptive Test Names</h2>

<p><em>October 16, 2014</em> - <a href="https://testing.googleblog.com/2014/10/testing-on-toilet-writing-descriptive.html">original
post</a></p>

<p>Vague test names make it hard to keep track of what is tested.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST_F(IsUserLockedOutTest, InvalidLogin) {
  authenticator_.Authenticate(username_, password_);
  EXPECT_FALSE(authenticator_.IsUserLockedOut(username_));

  authenticator_.Authenticate(username_, password_);
  EXPECT_FALSE(authenticator_.IsUserLockedOut(username_));

  authenticator_.Authenticate(username_, password_);
  EXPECT_TRUE(authenticator_.IsUserLockedOut(username_));
}
</code></pre>
</div>


<p>Descriptive test names make it easy to tell what behavior is broken without looking at code. Also,
the length of a good test name helps indicate when a test needs to be split apart.</p>


<div class="notices tip" ><pre><code class="language-cpp">TEST_F(IsUserLockedOutTest, ShouldLockOutUserAfterThreeInvalidLoginAttempts) {
 // ...
}
</code></pre>
</div>


<p>A test&rsquo;s name should be all you need to know to understand the behavior being tested. Make sure
the name contains both the scenario being tested and the expected outcome.</p>

<h2 id="don-t-put-logic-in-tests">Don&rsquo;t Put Logic in Tests</h2>

<p><em>July 31, 2014</em> - <a href="https://testing.googleblog.com/2014/07/testing-on-toilet-dont-put-logic-in.html">original
post</a></p>

<p>Tests should be simple by stating I/O directly rather than computing them.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST(NavigatorTest, ShouldNavigateToPhotosPage) {
  const std::string baseUrl = &quot;http://plus.google.com/&quot;;
  Navigator nav(baseUrl);
  nav.GoToPhotosPage();
  EXPECT_EQ(baseUrl + &quot;/u/0/photos&quot;, nav.GetCurrentUrl());
}
</code></pre>
</div>


<p>Even a simple string concatenation can lead to bugs.</p>


<div class="notices tip" ><pre><code class="language-cpp">TEST(NavigatorTest, ShouldNavigateToPhotosPage) {
  Navigator nav(&quot;http://plug.google.com/&quot;);
  nav.GoToPhotosPage();
  EXPECT_EQ(&quot;http://plus.google.com//u/0/photos&quot;, nav.GetCurrentUrl());
}
</code></pre>
</div>


<p>If a test requires logic, move that logic out of the test body into utilities and helper functions
and write tests for them too.</p>

<h2 id="risk-driven-testing">Risk-Driven Testing</h2>

<p><em>May 30, 2014</em> - <a href="https://testing.googleblog.com/2014/05/testing-on-toilet-risk-driven-testing.html">original
post</a></p>

<p>Blindly writing tests can lead to a false sense of security or wasted effort. Before writing tests,
think about testing. Small tests are cheap, larger tests protect core use-cases and integration.
Manual testing can sometimes be the cheapest, most effective option.</p>

<h2 id="effective-testing">Effective Testing</h2>

<p><em>May 7, 2014</em> - <a href="https://testing.googleblog.com/2014/05/testing-on-toilet-effective-testing.html">original
post</a></p>

<p>To be effective, a test maximizes three important qualities:</p>

<ul>
<li><strong>Fidelity</strong> - Sensitive to defects in the code under test.</li>
<li><strong>Resilience</strong> - Fails only when a breaking change is made to the code under test.</li>
<li><strong>Precision</strong> - Upon failure reports exactly where the defect lies.</li>
</ul>

<h2 id="test-behaviors-not-methods">Test Behaviors, Not Methods</h2>

<p>A single method can exhibit many behaviors. Likewise, a single behavior can span multiple methods.</p>

<p>It can be harmful to think that tests and public methods should have a 1:1 relationship.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST_F(TransactionProcessorTest, ProcessTransaction) {
  User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2));
  transaction_processor_.ProcessTransaction(user, Transaction(&quot;Pile of Beanie Babies&quot;, Dollars(3)));
  EXPECT_THAT(ui_.GetText(), HasSubstr(&quot;You bought a Pile of Beanie Babies&quot;));
  EXPECT_EQ(user.GetEmails().size(), 1);
  EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), &quot;Your balance is low&quot;);
}
</code></pre>
</div>


<p>Each test should verify one behavior. Each method may take several tests to verify.</p>


<div class="notices tip" ><pre><code class="language-cpp">TEST_F(TransactionProcessorTest, ShouldDisplayNotification) {
  transaction_processor_.ProcessTransaction(User(), Transaction(&quot;Pile of Beanie Babies&quot;));
  EXPECT_THAT(ui_.GetText(), HasSubstr(&quot;You bought a Pile of Beanie Babies&quot;));
}

TEST_F(TransactionProcessorTest, ShouldSendEmailWhenBalanceIsLow) {
  User user = NewUserWithBalance(kLowBalanceThreshold + Dollars(2));
  transaction_processor_.ProcessTransaction(user, Transaction(Dollars(3)));
  EXPECT_EQ(user.GetEmails().size(), 1);
  EXPECT_STREQ(user.GetEmails().at(0).GetSubject(), &quot;Your balance is low&quot;);
}
</code></pre>
</div>


<h2 id="what-makes-a-good-test">What Makes a Good Test?</h2>

<p>Tests provide more than verification. They also serve as documentation.</p>

<p>As a source of documentation, test should not be distracting or hide information.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST(CalculatorTest, ShouldPerformAddition) {
  Calculator calculator(RoundingStrategy(),
    &quot;unused&quot;, kEnableCosinFeature, 0.01, kCalculusEngine, false);
  int result = calculator.DoComputation(MakeTestComputation());
  EXPECT_EQ(result, 5);
}
</code></pre>
</div>



<div class="notices tip" ><pre><code class="language-cpp">TEST_(CalculatorTest, ShouldPerformAddition) {
  const int result = calculator_.DoComputation(MakeAdditionComputation(2, 3));
  EXPECT_EQ(result, 5);
}
</code></pre>
</div>


<h2 id="test-behavior-not-implementation">Test Behavior, Not Implementation</h2>

<p><em>August 5, 2013</em> - <a href="https://testing.googleblog.com/2013/08/testing-on-toilet-test-behavior-not.html">original
post</a></p>

<p>Except where explicitly intended, tests should work independent of the implementation details being
tested.</p>

<pre><code class="language-cpp">class Calculator {
 public:
  int Add(int a, int b)  {
    return a + b;
  }
};

class Calculator {
 public:
  int Add(int a, int b) {
    Adder adder = adder_factory_.CreateAdder();
    ReturnValue return_value = adder.Compute(Number(a), Number(b));
    return return_value.ConvertToInteger();
  }

 private:
  AdderFactory adder_factory_;
};

TEST_F(CalculatorTest, ShouldAddIntegers) {
  EXPECT_EQ(3, calculator_.Add(2, 1));
  EXPECT_EQ(2, calculator_.Add(2, 0));
  EXPECT_EQ(1, calculator_.Add(2, -1));
}
</code></pre>

<h2 id="know-your-test-doubles">Know Your Test Doubles</h2>

<p><em>July 18, 2013</em> - <a href="https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html">original
post</a></p>

<p>A test double is an object that can stand in for a real object in test. The most common types of
test doubles are:</p>

<ul>
<li><strong>Stub</strong> - Returns a specific values to promote a specific state.</li>
</ul>

<pre><code class="language-cpp">  AccessManager access_manager(kStubAuthenticationService);

  ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(false));
  EXPECT_FALSE(access_manager.UserHasAccess(kUserId));

  ON_CALL(kStubAuthenticationService, IsAuthenticated(kUserId)).WillByDefault(Return(true));
  EXPECT_TRUE(access_manager.UserHasAccess(kUserId));
</code></pre>

<ul>
<li><strong>Mock</strong> - Sets expectations about how other objects should interact with it.</li>
</ul>

<pre><code class="language-cpp">  AccessManager access_manager(mockAuthenticationService);

  EXPECT_CALL(mockAuthenticationService, IsAuthenticated(kUserId));
  access_manager.UserHasAccess(kUserId);
</code></pre>

<ul>
<li><strong>Fake</strong> - A lightweight implementation when the real implementation is unsuitable for test.</li>
</ul>

<pre><code class="language-cpp">  FakeAuthenticationService fake_authentication_service;
  AccessManager access_manager(fake_authentication_service);

  EXPECT_FALSE(access_manager.UserHasAccess(kUserId));

  fake_authentication_service.AddAuthenticatedUser(kUser);
  EXPECT_TRUE(access_manager.UserHasAccess(kUserId));
</code></pre>

<h2 id="fake-your-way-to-better-tests">Fake Your Way To Better Tests</h2>

<p><em>June 28, 2013</em> - <a href="https://testing.googleblog.com/2013/06/testing-on-toilet-fake-your-way-to.html">original
post</a></p>

<p>Suppose you would like to test your blog platform API, but you don&rsquo;t want your tests talking to a
remote server.</p>

<pre><code class="language-cpp">void DeletePostsWithTag(const Tag&amp; tag) {
  for (const Post post : blog_service_-&gt;GetAllPosts()) {
    if (post.HasTag(tag)) {
      blog_service_-&gt;DeletePost(post.GetId());
    }
  }
}
</code></pre>

<p>A fake is a lightweight implementation of an API that behaves like the real implementation, but
isn&rsquo;t suitable for production.</p>

<pre><code class="language-cpp">class FakeBlogService : public BlogService {
 public:
  void AddPost(const Post&amp; post) { posts.insert(post); }
  void DeletePost(const int id) {
    for (auto&amp; post : posts) {
      if (post.GetId() == id) { posts.erase(post); return; }
    }
  }
  std::set&lt;Post&gt; GetAllPosts() const { return posts; }

 private:
  std::set&lt;Post&gt; posts;
};
</code></pre>

<p>Fakes should be created and maintained by the person or team that owns the real implementation.</p>

<p>Fakes should have their own tests to make sure they behave like the real implementation.</p>

<h2 id="don-t-overuse-mocks">Don&rsquo;t Overuse Mocks</h2>

<p><em>May 28, 2013</em> - <a href="https://testing.googleblog.com/2013/05/testing-on-toilet-dont-overuse-mocks.html">original
post</a></p>

<p>Mocks are powerful, but easy to abuse.</p>


<div class="notices warning" ><pre><code class="language-cpp">TEST_F(PaymentProcessorTest, ShouldChargeCreditCard) {
  PaymentProcessor payment_processor(mock_credit_card_server_);

  InSequence s;
  EXPECT_CALL(mock_credit_card_server_, IsServerAvailable()).WillOnce(Return(true));
  EXPECT_CALL(mock_credit_card_server_, BeginTransaction()).WillOnce(Return(mock_transaction_manager_));
  EXPECT_CALL(mock_transaction_manager_, GetTransaction()).WillOnce(Return(transaction_));
  EXPECT_CALL(mock_credit_card_server_, Pay(transaction_, credit_card_, 500)).WillOnce(Return(mock_payment_));
  EXPECT_CALL(mock_payment_, IsOverMaxBalance()).WillOnce(Return(false));

  payment_processor.ProcessPayment(credit_card_, Dollars(500));
}
</code></pre>
</div>


<p>Overusing mocks makes tests harder to understand, maintain, and provides less insurance that your
code is working properly.</p>

<p>If you don&rsquo;t need a mock, don&rsquo;t use one. Understanding when to use a mock comes from understanding
what you want to test.</p>


<div class="notices tip" ><pre><code class="language-cpp">TEST_F(PaymentProcessorTest, ShouldChargeCreditCard) {
  PaymentProcessor payment_processor(credit_card_server_);
  payment_processor.ProcessPayment(credit_card_, Dollars(500));
  EXPECT_EQ(credit_card_server_.GetMostRecentCharge(credit_card_), 500);
}
</code></pre>
</div>


<h2 id="testing-state-vs-testing-interactions">Testing State vs. Testing Interactions</h2>

<p><em>March 22, 2013</em> -
<a href="https://testing.googleblog.com/2013/03/testing-on-toilet-testing-state-vs.html">original post</a></p>

<ul>
<li><strong>Testing State</strong> - Verifying the code under test returns the correct results.</li>
</ul>

<pre><code class="language-cpp">  TEST(NumberSorterTest, ShouldSortIntegers) {
    NumberSorter number_sorter({quicksort, bubblesort});
    std::vector&lt;int&gt; numbers = {3, 1, 2};
    EXPECT_EQ({1, 2, 3}, number_sorter.SortNumbers(numbers));
  }
</code></pre>

<ul>
<li><strong>Testing Interaction</strong> - Verifying the code under test calls methods correctly.</li>
</ul>

<pre><code class="language-cpp">  TEST(NumberSorterTest, ShouldUseQuicksort) {
    NumberSorter number_sorter({mock_quicksort, mock_bubblesort});
    std::vector&lt;int&gt; numbers = {3, 1, 2};
    EXPECT_CALL(mock_quicksort, Sort(numbers);
    number_sorter.SortNumbers(numbers);
  }
</code></pre>

<p>Most of the time you want to test state. Occasionally interactions need to be tested when the number
of calls or order of calls matter.</p>

<h2 id="code-coverage-goal-80-and-no-less">Code coverage goal: 80% and no less!</h2>

<p><em>July 20, 2010</em> -
<a href="https://testing.googleblog.com/2010/07/code-coverage-goal-80-and-no-less.html">original post</a></p>

<p>Early one morning, a young programmer asked the great master, “I am ready to write some unit tests.
What code coverage should I aim for?”</p>

<p>The great master replied, “Don’t worry about coverage, just write some good tests.”</p>

<p>The young programmer smiled, bowed, and left.</p>

<p>Later that day, a second programmer asked the same question. The great master pointed at a pot of
boiling water and asked, “How many grains of rice should I put in that pot?”</p>

<p>The programmer, looking puzzled, replied, “How can I possibly tell you? It depends on how many
people you need to feed, how hungry they are, what other food you are serving, how much rice you
have available, and so on.”</p>

<p>“Exactly,” said the great master.</p>

<p>The second programmer smiled, bowed, and left.</p>

<p>Toward the end of the day, a third programmer came and asked the same question about code coverage.</p>

<p>“Eighty percent and no less!” Replied the master in a stern voice, pounding his fist on the table.</p>

<p>The third programmer smiled, bowed, and left.</p>

<p>After this last reply, a young apprentice approached the great master, “Great master, today I
overheard you answer the same question about code coverage with three different answers. Why?”</p>

<p>The great master stood up from his chair. “Come get some fresh tea with me and let’s talk about it.”
After they filled their cups with smoking hot green tea, the great master began:</p>

<p>“The first programmer is new and just getting started with testing. Right now he has a lot of code
and no tests. He has a long way to go; focusing on code coverage at this time would be depressing
and quite useless. He’s better off just getting used to writing and running some tests. He can worry
about coverage later.</p>

<p>&ldquo;The second programmer, on the other hand, is quite experienced both at programming and testing.
When I replied by asking her how many grains of rice I should put in a pot, I helped her realize
that the amount of testing necessary depends on a number of factors, and she knows those factors
better than I do – it’s her code after all. There is no single, simple, answer, and she’s smart
enough to handle the truth and work with that.”</p>

<p>“I see,” said the young apprentice, “but if there is no single simple answer, then why did you tell
the third programmer ‘Eighty percent and no less’?”</p>

<p>The great master laughed so hard and loud that his belly, evidence that he drank more than just
green tea, flopped up and down. “The third programmer wants only simple answers – even when there
are no simple answers … and then does not follow them anyway.”</p>

<p>The young apprentice and the grizzled great master finished drinking their tea in contemplative
silence.</p>

<h2 id="data-driven-traps">Data Driven Traps!</h2>

<p><em>September 4, 2008</em> -
<a href="https://testing.googleblog.com/2008/09/tott-data-driven-traps.html">original post</a></p>

<p>Data driven tests are efficient, but easy to abuse.</p>


<div class="notices warning" ><pre><code class="language-cpp">struct TestData {
  const std::string word;
  const bool is_word;
};

const std::vector&lt;TestData&gt; test_data = {
    {&quot;milk&quot;, true},
    {&quot;centre&quot;, false},
    {&quot;jklm&quot;, false},
};

TEST(IsWordTest, TestEverything) {
  for (const auto&amp; entry : test_data) {
    EXPECT_EQ(IsWord(entry.word), entry.is_word);
  }
}
</code></pre>
</div>


<p>Data-driven tests make debugging and understanding failures, let alone false positives, more
difficult.</p>

<p>As the code grows in complexity, data tends to grow even faster. It quickly becomes impossible to
discern what behavior each piece of data is meant to test.</p>


<div class="notices warning" ><pre><code class="language-cpp">const std::vector&lt;Locale&gt; locales = { Word::US, Word::UK, Word::France, ... };

struct TestData {
  std::string word;
  bool[kNumLocales] is_word;
};

const std::vector&lt;TestData&gt; test_data = {
    {&quot;milk&quot;, {true, true, false, ...},
    {&quot;centre&quot;, {false, true, true, ...}},
    {&quot;jklm&quot;, {false, false, false, ...}},
};

TEST(IsWordTest, TestEverything) {
  for (const auto&amp; entry : test_data) {
    for (const auto* locale: locales) {
      EXPECT_EQ(IsWord(entry.word, locale), entry.is_word);
    }
  }
}
</code></pre>
</div>


<p>Instead, think critically about what behaviors are worth testing.</p>


<div class="notices tip" ><pre><code class="language-cpp">TEST(IsWordTest, ShouldExistInMultipleLocales) {
  EXPECT_TRUE(IsWord(&quot;milk&quot;, Word::US));
  EXPECT_TRUE(IsWord(&quot;milk&quot;, Word::UK));
  EXPECT_FALSE(IsWord(&quot;milk&quot;, Word::France));
}

TEST(IsWordTest, ShouldNotExist) {
  // &quot;jklm&quot; test not repeated as it uses the same code path
  EXPECT_FALSE(IsWord(&quot;jklm&quot;, Word::US));
}
</code></pre>
</div>


<h2 id="sleeping-synchronization">Sleeping != Synchronization</h2>

<p><em>August 21, 2008</em> -
<a href="https://testing.googleblog.com/2008/08/tott-sleeping-synchronization.html">original post</a></p>

<p>Beware of <code>sleep</code>. <code>sleep</code> should never be used for synchronization, or in test.</p>


<div class="notices warning" ><pre><code class="language-cpp">class CoffeeMaker {
 public:
  virtual ~CoffeeMaker() = default;
  virtual void MakeCoffee(const std::function&lt;void()&gt; callback) = 0;
};

class Intern : public CoffeeMaker {
 public:
  void MakeCoffee(const std::function&lt;void()&gt; callback) {
    // make coffee, hopefully within 60 seconds.
    callback();
  }
};

class Employee {
 public:
  void DrinkCoffee() { caffeinated_ = true; }
  bool IsCaffeinated() { return caffeinated_; }

  void DemandCoffee(CoffeeMaker&amp; cm) {
    std::thread t(&amp;CoffeeMaker::MakeCoffee, &amp;cm,
                  std::bind(&amp;Employee::DrinkCoffee, this));
    t.detach();
  }

 private:
  bool caffeinated_ = false;
};

TEST(EmployeeTest, ShouldBeCaffeinatedOnlyAfterDrinkingCoffee) {
  Employee e;
  Intern i;
  e.DemandCoffee(i);
  EXPECT_FALSE(e.IsCaffeinated());
  std::this_thread::sleep_for(60s);
  EXPECT_TRUE(e.IsCaffeinated());
}
</code></pre>
</div>


<p>Code that sleeps can be improved by waiting on a <code>std::future</code> or a <code>std::condition_variable</code>.
As always, if your waiting on a non-trivial operation, like <code>Intern::MakeCoffee</code>, use a fake.</p>


<div class="notices tip" ><pre><code class="language-cpp">class FakeIntern : public CoffeeMaker {
 public:
  void MakeCoffee(const std::function&lt;void()&gt; callback) {
    std::unique_lock&lt;std::mutex&gt; lock(mut_);
    cv_.wait(lock, [this] { return ready_; });

    callback();
    done_ = true;

    lock.unlock();
    cv_.notify_one();
  }

  void SignalAndWait() {
    std::unique_lock&lt;std::mutex&gt; lock(mut_);
    ready_ = true;
    cv_.notify_one();

    cv_.wait(lock, [this] { return done_; });
  }

 private:
  bool ready_ = false;
  bool done_ = false;
  std::condition_variable cv_;
  std::mutex mut_;
};

TEST(EmployeeTest, ShouldBeCaffeinatedOnlyAfterDrinkingCoffee) {
  Employee e;
  FakeIntern i;
  e.DemandCoffee(i);
  EXPECT_FALSE(e.IsCaffeinated());
  i.SignalAndWait();
  EXPECT_TRUE(e.IsCaffeinated());
}
</code></pre>
</div>


<h2 id="defeat-static-cling">Defeat &ldquo;Static Cling&rdquo;</h2>

<p><em>June 26, 2008</em> -
<a href="https://testing.googleblog.com/2008/06/defeat-static-cling.html">original post</a></p>

<p>Static functions, like this singleton <code>GetInstance</code> method, are a sign of tight coupling.</p>

<pre><code class="language-cpp">class MyObject {
 public:
  int DoSomething(int id) {
    return TheirEntity::GetInstance().GetSomething(id);
  }
};
</code></pre>

<p>There is a way around this using the Repository Pattern.</p>

<pre><code class="language-cpp">class TheirEntityRepository {
 public:
  virtual ~TheirEntityRepository() = default;
  virtual TheirEntity&amp; GetInstance() = 0;
  // Other static methods here
};

class TheirEntityStaticRepository : public TheirEntityRepository {
 public:
  TheirEntity&amp; GetInstance() { return TheirEntity::GetInstance(); }
};

class MyObject {
 public:
  explicit MyObject(std::unique_ptr&lt;TheirEntityRepository&gt; repository)
      : repository_(std::move(repository)) {}
  int DoSomething(int id) { return repository_-&gt;GetInstance().GetSomething(); }

 private:
  std::unique_ptr&lt;TheirEntityRepository&gt; repository_;
};
</code></pre>

<p>All thats left is to derive a <code>MockTheirEntityRepository</code> suitable for your testing needs.</p>

<h2 id="testable-contracts-make-exceptional-neighbors">Testable Contracts Make Exceptional Neighbors</h2>

<p><em>May 28, 2008</em> -
<a href="https://testing.googleblog.com/2008/05/tott-testable-contracts-make.html">original post</a></p>

<p>Modify external visible state only after completing all operations which could possibly fail.</p>


<div class="notices warning" ><pre><code class="language-cpp">bool SomeCollection::GetObjects(std::vector&lt;Object&gt;&amp; objects) const {
  objects.clear();
  for (const auto&amp; object : collection_) {
    if (object.IsFubarred()) return false;
    objects.push_back(object);
  }
  return true;
}
</code></pre>
</div>


<p>In these situations, the <code>swap</code> trick comes in handy.</p>


<div class="notices tip" ><pre><code class="language-cpp">bool SomeCollection::GetObjects(std::vector&lt;Object&gt;&amp; objects) const {
  std::vector&lt;Object&gt; known_good_objects;
  for (const auto&amp; object : collection_) {
    if (object.IsFubarred()) return false;
    known_good_objects.push_back(object);
  }
  objects.swap(known_good_objects);
  return true;
}
</code></pre>
</div>


<p>Now, the caller has good objects on success, or unchanged objects on failure.</p>

<h2 id="understanding-your-coverage-data">Understanding Your Coverage Data</h2>

<p><em>March 6, 2008</em> -
<a href="https://testing.googleblog.com/2008/03/tott-understanding-your-coverage-data.html">original post</a></p>

<p>High test coverage is necessary but not sufficient.</p>

<p>Use your test coverage results to look for unexpected coverage patterns, which usually indicate
bugs, and add test cases to address them.</p>

<h2 id="too-many-tests">Too Many Tests</h2>

<p><em>February 21, 2008</em> -
<a href="https://testing.googleblog.com/2008/02/in-movie-amadeus-austrian-emperor.html">original post</a></p>

<p>How many tests? Answering this question requires a good grasp of the context.</p>

<pre><code class="language-cpp">void Decide(int32_t a, int32_t b, int32_t c, int32_t d, int32_t e, int32_t d) {
  if (a &gt; b || c &gt; d || e &gt; f) {
    DoOneThing();
  } else {
    DoAnother();
  }
}
</code></pre>

<ul>
<li>Testing every possible input would require 2<sup>192</sup> tests. Thats too many.</li>
<li>Testing enough to get full line coverage would require 2 tests. Thats too few.</li>
<li>Testing each logical expression (e.g <code>a &gt; b</code>, <code>a == b</code>, <code>a &lt; b</code>) independently is 27 tests. Still
probably too many.</li>
</ul>

<p>More context can focus the decision.</p>

<pre><code class="language-cpp">void Decide(int32_t a, int32_t b, int32_t c, int32_t d, int32_t e, int32_t d) {
  if (TallerThan(a, b) || HarderThan(c, d) || HeavierThan(e, f)) {
    DoOneThing();
  } else {
    DoAnother();
  }
}

bool TallerThan(int32_t a, int32_t b) { return a &gt; b; }
bool HarderThan(int32_t c, int32_t d) { return d &gt; d; }
bool HeavierThan(int32_t e, int32_t f) { return e &gt; f; }
</code></pre>

<p>Testing the cases where each extracted function is true, they all are false, and writing 2 tests for
each of the extracted functions would require 4 + 3*2 = 10 tests. Considering the number of inputs,
thats just enough tests.</p>

<h2 id="avoiding-friend-twister-in-c">Avoiding Friend Twister in C++</h2>

<p><em>October 30, 2007</em> -
<a href="https://testing.googleblog.com/2007/10/tott-avoiding-friend-twister-in-c.html">original post</a></p>

<p>&ldquo;Testing private members requires more <code>friend</code> contortions than a game of Twister®.&rdquo;</p>

<p>If you find yourself saying that, theres a better way.</p>


<div class="notices warning" ><pre><code class="language-cpp">// include/my_project/dashboard.h

class Dashboard {
 private:
  // Declaration of functions getResults(), GetResultsFromCache(),
  // GetResultsFromDatabase(), and CountPassFail()

  std::unique_ptr&lt;Database&gt; database_; // instantiated in constructor

  friend class DashboardTest; // one friend declaration per test fixture
};
</code></pre>
</div>


<p>Instead, make a helper class by extracting a helper class (a variant of the Pimple idiom).</p>

<p>To preserve privacy, the helper class is tucked away in a private implementation directory separate
from the public API.</p>


<div class="notices tip" ><pre><code class="language-cpp">// include/my_project/dashboard.h

class ResultsLog; // Foreword declare extracted helper interface

class Dashboard {
 public:
  explicit Dashboard(std::unique_ptr&lt;ResultsLog&gt; results)
      : results_(std::move(results)) {}

 private:
   std::unique_ptr&lt;ResultsLog&gt; results_;
};

// src/results_log.h

class ResultsLog {
 public:
  // Declaration of functions getResults(), GetResultsFromCache(),
  // GetResultsFromDatabase(), and CountPassFail()
};

// src/live_results_log.h

class LiveResultsLog : public ResultsLog {
 public:
  explicit LiveResultsLog(std::shared_ptr&lt;Database&gt; database)
      : database_(std::move(database)) {}
};
</code></pre>
</div>


<p>As an added bonus, now you can inject a <code>MockResultsLog</code> or a <code>FakeDatabase</code> for testing the
<code>Dashboard</code> class.</p>

<h2 id="refactoring-tests-in-the-red">Refactoring Tests in the Red</h2>

<p><em>April 26, 2007</em> -
<a href="https://testing.googleblog.com/2007/04/tott-refactoring-tests-in-red.html">original post</a></p>

<p>As your test suite grows, you will find yourself needing to refactor your tests. However,
your tests don&rsquo;t have tests!</p>

<p>One thing you can do is intentionally break the test, refactor the test, and make sure the test
still fails as expected.</p>

<p>Just remember to revert your code under test!</p>


<footer class=" footline" >
	
</footer>


        
        </div> 
        

      </div>

    <div id="navigation">
        
        
        
        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
            
        
        
        


	 
	 
		
			<a class="nav nav-prev" href="/google-testing-blog/whittaker/" title="James Whittaker"> <i class="fa fa-chevron-left"></i></a>
		
		
			<a class="nav nav-next" href="/google-testing-blog/general/" title="General Notes" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
		
	
    </div>

    </section>
    
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="/js/clipboard.min.js?1564022436"></script>
    <script src="/js/perfect-scrollbar.min.js?1564022436"></script>
    <script src="/js/perfect-scrollbar.jquery.min.js?1564022436"></script>
    <script src="/js/jquery.sticky.js?1564022436"></script>
    <script src="/js/featherlight.min.js?1564022436"></script>
    <script src="/js/html5shiv-printshiv.min.js?1564022436"></script>
    <script src="/js/highlight.pack.js?1564022436"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/js/modernizr.custom-3.6.0.js?1564022436"></script>
    <script src="/js/learn.js?1564022436"></script>
    <script src="/js/hugo-learn.js?1564022436"></script>

    <link href="/mermaid/mermaid.css?1564022436" rel="stylesheet" />
    <script src="/mermaid/mermaid.js?1564022436"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
    

  </body>
</html>

